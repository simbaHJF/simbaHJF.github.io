---
layout:     post
title:      "LINUX IO模型"
date:       2019-06-10 22:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---





Unix下I/O分为5中模型:
*  阻塞式I/O
*  非阻塞式I/O
*  I/O复用(select和poll)
*  信号驱动式I/O(SIGIO)
*  异步I/O(POSIX的aio_系列函数)

首先明确一个前提,一个输入操作通常包括两个不同的阶段:
1.  等待数据准备好
2.  从内核向进程复制数据

对于一个套接字的上述过程,第一步通常涉及等待数据从网络中到达.当所等待的分组到达时,它被复制到内核中的某个缓冲区.第二步就是把数据从内核缓冲区复制到应用进程缓冲区.

####  阻塞I/O模型
阻塞I/O即通常我们说的BIO(blocking I/O),它的I/O模型如下图:
![阻塞式I/O模型](https://s2.ax1x.com/2019/06/11/Vcua7Q.png)

进程调用recvfrom,其系统调用知道数据包到达并且被复制到用户空间中或者发生错误才返回.进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的.recvfrom成功返回后,引用进程开始处理数据报.
在内核等待数据准备好和将数据从内核复制到用户空间这两步,都发生阻塞.

####  非阻塞式I/O模型
进程把一个套接字设置成非阻塞是在通知内核:当所请求的I/O操作非得把本进程投入睡眠才能完成时,不要把进程投入睡眠,而是返回一个错误.它的I/O模型如下图:
![非阻塞式I/O模型](https://s2.ax1x.com/2019/06/11/VcKeCn.png)
前三次调用recvfrom时没有数据可返回,因此内核转而立即返回一个EWOULDBLOCK错误.第四次调用recvfrom时已有一个数据报准备好,它被复制到应用进程缓冲区,于是recvfrom成功返回,引用进程可以处理数据了.
当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时,称之为轮询(polling),引用进程持续轮询内核,以查看某个操作是否就绪.这么做往往耗费大量CPU时间,使用场景很少.

####  I/O复用模型
通过select可以实现I/O的复用.在I/O复用模型下,进程是阻塞在select这个系统调用上,而不是阻塞在真正的I/O系统调用上.
![I/O复用模型](https://s2.ax1x.com/2019/06/11/VcKrUH.png)
其过程为,进程阻塞于select调用,等待数据报套接字变为可读.当select返回套接字可读这一条件时,调用recvfrom把所读数据报从内核复制到应用进程缓冲区.
I/O复用需要使用到select和recvfrom两个系统调用,所以甚至还稍有劣势,但它的关注点不在I/O速度这方面,而在于复用,由一个进程管理多个I/O进程.

####  信号驱动式I/O模型
使用信号,让内核在描述符就绪时发送SIGIO信号通知应用进程.这种模型成为信号驱动式I/O.
![信号驱动式I/O模型](https://s2.ax1x.com/2019/06/11/VcKIaQ.png)
通过sigaction系统调用安装一个信号处理函数,该系统调用会立即返回,应用进程继续工作并不阻塞,当数据报准备好读取时,内核为应用进程产生一个SIGIO信号.随后应用进程在信号处理程序中调用recvfrom系统调用,来读取数据报.

以上4种I/O模型中,应用进程阻塞不阻塞都是讲的在内核数据还没有准备好,等待数据时,应用进程是否阻塞,而在内核数据准备好进行复制数据报,将数据从内核复制到用户空间的这一步,应用进程是都会发生阻塞的.这点要尤其注意!!!!

####  异步I/O模型
异步I/O的工作机制是:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到用户空间,这点很重要)完成后通知我们.这种模型与前面的信号驱动模型的主要区别是:信号驱动式I/O是由内核通知应用进程何时可以启动一个I/O操作,而异步I/O模型是由内核通知应用进程I/O何时完成.所以,在异步I/O模型下,无论是内核等待数据阶段还是将数据从内核复制到用户空间阶段,应用进程都不会阻塞.
![异步I/O模型](https://s2.ax1x.com/2019/06/11/VcKOMV.png)

####  各种I/O模型的比较总结
前4种模型的主要区别在于第一阶段,因为它们的第二阶段是一样的:在数据从内核复制到用户空间期间,进程阻塞于recvfrom调用,因此它们都是同步I/O.而异步I/O则与前面4种不同,用户进程在两个阶段均不会被阻塞

![5种I/O模型的比较](https://s2.ax1x.com/2019/06/11/VcMixx.png)

####  同步I/O和异步I/O的对比
POSIX把这两个术语定义如下:
*  同步I/O操作  导致请求进程阻塞,直到I/O操作完成
*  异步I/O操作  不导致请求进程阻塞

根据上述定义,上述前4种模型----阻塞式I/O模型,非阻塞式I/O模型,I/O复用模型和信号驱动式I/O模型都是同步I/O模型,因为其中真正的I/O操作(recvfrom)将阻塞进程.只有异步I/O模型与POSIX定义的异步I/O相匹配,即不会导致请求进程阻塞.


