---
layout:     post
title:      "操作系统内存管理"
date:       2019-06-11 22:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

>参考资料:<br>
>极客时间<br>
>计算机操作系统(第四版)

### 连续分配存储管理方式
为了能将用户程序装入内存,必须为它分配一定大小的内存空间.连续分配方式是最早出现的一种存储器分配方式.该分配方式为一个用户程序分配一个连续的内存空间,即程序中代码或数据的逻辑地址相邻,体现在内存空间分配时物理地址的相邻.


### 虚拟内存地址
当我们需要在系统中同时运行多道程序时,无法保证某道程序加载在固定的内存段上,也就不能固定程序在内存的加载位置和指令在内存中的绝对地址.
为解决此问题,在内存中找到一段连续的内存空间,将其分配给装载的程序,然后把这段物理内存空间地址和整个程序指令的指定地址做一个映射.物理地址对于进程不可见,操作系统给进程分配一个虚拟地址.所有进程看到的这个地址都是一样的,在程序里面指令的地址都是虚拟地址,当程序要访问虚拟地址的时候,由内核的数据结构进行转换,转换成不同的物理地址.
我们把程序中指令用到的内存地址叫做虚拟内存地址,实际在内存硬件里面的空间地址,叫做物理内存地址.

虚拟地址空间又分为内核空间和用户空间两部分.32位系统的内核空间占用1G,位于高位,剩下的3G是用户空间.而64位系统的内核空间和用户空间都是128T,分别占据整个内存空间的最高处和最低处,剩下的中间部分是未定义的.
![V570Qs.png](https://s2.ax1x.com/2019/06/14/V570Qs.png)

进程在用户态时,只能访问用户空间内存;只有进入内核态后,才可以访问内核空间内存.进程间的内存是隔离的,但各个进程的内核空间,关联的都是相同的物理内存.虚拟内存空间的分布情况如下图:
![V5bOsA.png](https://s2.ax1x.com/2019/06/14/V5bOsA.png)
用户空间内存,从低到高分别是五中不同的内存段.
1. 只读段,包括代码和常量等
2. 数据段,包括全局变量等
3. 堆,包括动态分配的内存,从地地址开始向上增长
4. 文件映射段,包括动态库,共享内存等,从高地址开始向下增长
5. 栈,包括局部变量和函数调用的上下文等
在这五个内存段中,堆和文件映射段的内存是动态分配的.比如说,使用C标准库的malloc()或者mmap(),就可以分别在堆和文件映射段动态分配内存.


### 内存交换(Swapping)
连续分配存储管理方式和虚拟内存地址的结合解决了最初的内存分配问题,但也存在明显的不足,第一个就是内存碎片问题.
例如,我们当前有一台电脑,内存为1GB.我们首先启动一个图形渲染程序,占用512MB内存;接着启动一个Chrome浏览器,占用128MB内存;再启动一个Python程序,占用256MB内存.这时,关掉Chrome,于是空闲内存还有256MB.按理来说,我们有足够的内存空间装在一个200MB的程序.但是,这256MB的内存空间不是连续的,而是被分成了两段128MB的内存.导致那200MB的程序无法被加载进来.
解决上述问题的办法,我们称之为内存交换.
我们可以把Python程序占用的那256MB内存写到硬盘上,然后再从硬盘上读回来到内存里面.不过读回来的时候,不再把它加载到原来的位置,而是紧跟在那已被占用的512MB内存后面.这样就有了256MB的连续内存空间,可以去加载一个新的200MB的程序.如果你自己安装过linux操作系统,你应该遇到过分配一个swap硬盘分区的问题.这块分出来的磁盘空间,其实就是专门给linux操作系统进行内存交换用的.
内存交换不仅用在上述场景中,还可应用于下面这种情况:一方面,在内存中的某些进程由于某件事尚未发生而被阻塞运行,但它却占用了大量的内存空间,甚至阻塞其他进程;另一方面,却又有许多作业,因为内存空间不足,一直驻留在外存上,而不能进入内存运行.显然这是对系统资源的严重浪费,使视同吞吐量下降.这个问题,也可通过内存交换解决,把内存中暂时不能运行的进程或暂时不用的程序和数据换出到外存,以便腾出足够的内存空间,再把已具备运行条件的进程或进程所需要的程序和数据换入内存.


### 离散分配存储管理方式
连续分配存储的方式会形成许多碎片,虽然可通过内存交换的方式进行紧凑,将碎片拼接成可用的大块空间,但需要付出很大的系统开销.如果允许将一个进程直接分散地装入到许多不相邻接的分区中,便可充分利用内存空间,降低内存交换的次数同时降低交换涉及到的内存空间大小.基于这种思想而产生了离散分配方式.根据在离散分配时所分配地址空间的基本单位的不同,又可将离散分配分为以下三种:
* 分页存储管理方式
* 分段存储管理方式
* 段页式存储管理方式

##### 一.分页存储管理方式
将用户程序的地址空间分为若干个固定大小的区域,称为"页"或"页面";将物理内存空间也分为若干个物理块或页框.页和页框大小相同.这样可将用户程序的任一页放入任一物理块中,实现离散分配.在为进程分配内存时,将进程中的若干个页分别装入到多个可以不相邻接的物理块中.由于进程的最后一页经常装不满一块,而形成了不可利用的碎片,称之为"页内碎片".在linux系统下,页大小通常设置为4KB.

分页地址中的地址结构如下:
![](https://s2.ax1x.com/2019/06/12/VWMfOI.png)
它包含两部分内容:前一部分为页号,后一部分为偏移量,即页内地址.

在分页系统中,允许将进程的各个页离散地存储在内存的任一物理块中,为保证进程仍然能够正确地运行,即能在内存中找到每个页面所对应的物理块,系统又为每个进程建立了一张页面映射表,简称页表.在进程地址空间内的所有页,依次在页表中有一个页表项,其中记录了相应页在内存中对应的物理块号.在配置了页表后,进程执行时,通过查找该表,即可找到每页在内存中的物理块号.因此,页表的作用是实现从页号到物理块号的地址映射.如下图:
![](https://s2.ax1x.com/2019/06/12/VW18TP.png)

当进程访问的虚拟地址在页表中查不到时,系统会产生一个缺页异常,进入内核空间分配物理内存,更新页表,最后在返回用户空间,恢复进程的运行了.

页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大,比如32位系统就需要4GB/4KB个页表项才可以实现整个地址空间的映射.为了解决页表项过多的问题,Linux提空了两种机制,也就是多级页表和大页.
多级页表就是把内存分成去快来管理,将原来的映射关系改成区块索引和区块内的偏移.由于虚拟内存空间通常只使用了很少一部分,那么,多级页表就只保存这些使用中的区块,这样就可以大大减少页表的项数.
linux用的正式四级页表来管理内存页,如下图所示,虚拟地址被分为5个部分,前4个表项用于选择页,而最后一个索引表示页内偏移.
[![V5LJXj.md.png](https://s2.ax1x.com/2019/06/14/V5LJXj.md.png)](https://imgchr.com/i/V5LJXj)

再看大页,顾名思义,就是比普通页更大的内存块,常见的大小有2MB和1GB.大页通常用在使用大量内存的进程上,比如Oracle等.


##### 二.分段存储管理方式
引入分段存储管理方式的目的,主要是为了满足用户(程序员)在编程和使用上多方面的要求.在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息.例如,有主程序段MAIN,子程序段X,数据段D及栈段S等.每个段有一个段号,每个段从0开始编址,并采用一段连续的地址空间.段的长度由相应的逻辑信息组的长度决定,因此各段的长度并不相等.整个作业的地址空间由于被分成多个段,所以呈现出二维特性.每个段既包含了一部分地址空间,又标识了逻辑关系.其逻辑地址由段号和段内地址组成.

分段地址中的地址具有如下结构:
![VWNQ9x.png](https://s2.ax1x.com/2019/06/12/VWNQ9x.png)

在分段式存储管理系统中,为每个分段分配一个连续的分区.进程中的各个段,可以离散地装入内存中不同的分区中.为保证程序能正常运行,就必须能从物理内存中找出没给个逻辑段对应的位置.为此,在系统中,类似于分页系统,需要为每个进程建立一张段映射表,简称"段表".每个段在表中占有一个表项,其中记录了该段在内从中的起始地址(又称为"基址")和段的长度.在配置了段表后,执行中的进程可通过查找段表,找到每个段所对应的内存区.可见,段表是用于实现从逻辑段到物理内存区的映射的.
[![VWUULF.png](https://s2.ax1x.com/2019/06/12/VWUULF.png)](https://imgchr.com/i/VWUULF)


##### 三.分页和分段的主要区别
分页和分段系统又许多相似之处.两者都采用离散分配方式,且都是通过地址映射机构(通常有硬件实现,因为需要地址映射的频率很高)实现地址变换.但在概念上两者完全不同,主要表现在下述三个方面:
1. 页是信息的物理单位.采用分页存储管理方式是为实现离散分配方式,以消减内存的外零头,提高内存的利用率.或者说,分页仅仅只是系统管理上的需要,完全是系统的行为,对用户是不可见的.分段存储管理方式中的段则是信息的逻辑单位,它通常包含的是一组意义相对完整的信息.分段的目的主要在于能更好地满足用户的需要.
2. 页的大小固定且由系统决定.在采用分页存储管理方式的系统中,在硬件结构上,就把用户程序的逻辑地址划分为页号和页内地址两部分,也就是说是直接由硬件实现的,因而在每个系统中只能有一种大小的页面.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分.
3. 分页的用户程序地址空间是一维的.分页完全是系统的行为,故在分液系统中,用户程序的地址是属于单一的线性地址空间.而分段是用户的行为,故在分段系统中,用户程序的地址空间是二维的,程序员在标识一个地址时,既需给出段名(段号),又需给出段内地址.


##### 四.段页式存储管理方式
段页式系统的基本原理是分段和分页的集合,即现将用户程序分成若干个段,再把每个段分成若干个页,并未每一个段赋予一个段名(段号),下面给出一个作业地址空间的结构:
![V5Odrd.png](https://s2.ax1x.com/2019/06/14/V5Odrd.png)
该作业有三个段:主程序段,子程序段和数据段;页面大小为4KB.在段页式系统中,其地质结构由段号,段内页号及页内地址三部分组成.
在段页式系统中,为了实现从逻辑地址到物理地址的变换,系统中需要同时配置段表和页表.
[![V5XaWT.md.png](https://s2.ax1x.com/2019/06/15/V5XaWT.md.png)](https://imgchr.com/i/V5XaWT)



