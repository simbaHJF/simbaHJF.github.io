---
layout:     post
title:      "mysql事务"
date:       2019-09-19 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	事务的隔离性与隔离级别
事务特性:ACID(Atomicity,Consistency,Isolation,Durability)

隔离级别与隔离性:

隔离级别 | 隔离性 |
-|-|
读未提交  |  脏读  |
读已提交  |  不可重复读  |
可重复读  |  幻读  |
串行化  |  -  |

在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准.在"可重复读"隔离级别下,这个视图是在事务启动时创建的,整个事务存在期间都用这个视图.在"读提交"隔离级别下,这个视图是在每个SQL语句开始执行的时候创建的.这里需要注意的是,"读未提交"隔离级别下直接返回记录上的最新值,并没有视图的概念;而"串行化"隔离级别下直接用加锁的方式来避免并行访问.

##	事务隔离的实现
在MySQL中,每条记录在更新的时候都会同时记录一条回滚操作.记录上的最新值,通过回滚操作,都可以得到前一个状态的值.
假如一个值从1被按顺序改成了2,3,4,在回滚日志里面就会有类似下面的记录.

![nbXhdA.png](https://s2.ax1x.com/2019/09/19/nbXhdA.png)

当前值是4,但是在查询这条记录的时候,不同时刻启动的事务会有不同的read-view.如图中看到的,在视图A,B,C,这一个记录的值分别是1,2,4,同一条记录在系统中可以存在多个版本,这就是数据库的多版本并发控制(MVCC).对于read-view A,要得到1,就必须将当前值依次执行图中所有的回滚操作得到.

回滚日志不能一直保留,会在不需要的时候删除,系统会判断,当没有事务再需要用到这些回滚日志时,回滚日志会被删除.什么时候才不需要了呢?就是当系统里没有比这个回滚日志更早的read-view的时候




##	事务
在MySQL里,有两个"视图"的概念:
*	一个是view.它是一个晕查询语句定义的虚拟表,在调用的时候执行查询语句并生成结果.
*	另一个是InnoDB在实现MVCC时用到的一致性读视图,即consistent read view,用于支持RC(Read Committed,读提交)和RR(Repeatable Read,可重复读)隔离级别的实现.它没有物理结构,作用是事务执行期间用来定义"能看到什么数据".

####	快照在MVCC里是怎么工作的
在RR级别下,事务在启动的时候就"拍了个快照",这个快照是基于整库的,但并不是整库拷贝一份.来看下它是怎么实现的:

InnoDB里面每个事务有一个唯一的事务ID,叫做transaction id.它是在事务开始的时候向InnoDB的事务系统申请的,是按申请顺序严格递增的.

而每行数据也都是有多个版本的,每次事务更新数据的时候,都会生成一个新的数据版本,并且把transaction id赋值给这个数据版本的事务ID,记为 row trx_id.同时,旧的数据版本要保留,并且在新的数据版本中,能够有信息可以直接拿到它.也就是说,数据表中的一行记录,其实可能有多个版本(row),每个版本有自己的row trx_id.如下图所示,就是一个记录被多个事务连续更新后的状态.
![unaPwF.png](https://s2.ax1x.com/2019/09/26/unaPwF.png)

图中虚线框里是同一行数据的4个版本,当前最新版本是V4,k的值是22,它是被transaction id为25的事务更新的,因此它的row trx_id也是25.

前面基础篇有提到过undo log(回滚日志),那么undo log在哪呢?实际上,图中的三个虚线箭头,就是undo log;而V1,V2,V3并不是物理上真实存在的,而是每次需要的时候根据当前版本和undo log计算出来的.比如,需要V2的时候,就是通过V4依次执行U3,U2两个undo log算出来的.

而快照的生成就是,InnoDB为每个事务构造一个数组,用来保存这个事务启动瞬间,当前正在"活跃"的所有事务ID."活跃"指的就是,启动了但还没提交.

数组里面事务ID的最小值记为低水位,当前系统里面已经创建过的事务ID的最大值加1记为高水位.这个是图书组和高水位,就组成了当前事务的一致性视图.MySQL内部就是通过这个数组来判断可见性的.但这个逻辑比较复杂,人肉分析很麻烦.

可以用如下方式判断可见性:
1.	版本未提交,不可见;
2.	版本已提交,但是是在视图创建后提交的,不可见;
3.	版本已提交,而且是在视图创建前提交的,可见.

####	更新逻辑
如下图
![un6AYT.png](https://s2.ax1x.com/2019/09/26/un6AYT.png)

事务B的视图数组是先生成的,之后事务C才提交,不是应该看不见(1,2)吗,怎么能算出(1,3)来?

是的,如果事务B在更新之前查询一次数据,这个查询返回的k的值确实是1.但是,当它要去更新数据的时候,就不能在历史版本上更新了,否则事务C的更新就丢失了.因此事务B此时的set k=k+1是在(1,2)的基础上进行的操作.

所以,这里有这样一条规则:更新数据都是先读后写的,而这个读,只能读当前的值,称为"当前读"