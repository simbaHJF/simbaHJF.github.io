---
layout:     post
title:      "mysql事务"
date:       2019-09-19 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	事务的隔离性与隔离级别
事务特性:ACID(Atomicity,Consistency,Isolation,Durability)

隔离级别与隔离性:

隔离级别 | 隔离性 |
-|-|
读未提交  |  脏读  |
读已提交  |  不可重复读  |
可重复读  |  幻读  |
串行化  |  -  |

在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准.在"可重复读"隔离级别下,这个视图是在事务启动时创建的,整个事务存在期间都用这个视图.在"读提交"隔离级别下,这个视图是在每个SQL语句开始执行的时候创建的.这里需要注意的是,"读未提交"隔离级别下直接返回记录上的最新值,并没有视图的概念;而"串行化"隔离级别下直接用加锁的方式来避免并行访问.

##	事务隔离的实现
在MySQL中,每条记录在更新的时候都会同时记录一条回滚操作.记录上的最新值,通过回滚操作,都可以得到前一个状态的值.
假如一个值从1被按顺序改成了2,3,4,在回滚日志里面就会有类似下面的记录.

![nbXhdA.png](https://s2.ax1x.com/2019/09/19/nbXhdA.png)

当前值是4,但是在查询这条记录的时候,不同时刻启动的事务会有不同的read-view.如图中看到的,在视图A,B,C,这一个记录的值分别是1,2,4,同一条记录在系统中可以存在多个版本,这就是数据库的多版本并发控制(MVCC).对于read-view A,要得到1,就必须将当前值依次执行图中所有的回滚操作得到.

回滚日志不能一直保留,会在不需要的时候删除,系统会判断,当没有事务再需要用到这些回滚日志时,回滚日志会被删除.什么时候才不需要了呢?就是当系统里没有比这个回滚日志更早的read-view的时候




##	事务
在MySQL里,有两个"视图"的概念:
*	一个是view.它是一个晕查询语句定义的虚拟表,在调用的时候执行查询语句并生成结果.
*	另一个是InnoDB在实现MVCC时用到的一致性读视图,即consistent read view,用于支持RC(Read Committed,读提交)和RR(Repeatable Read,可重复读)隔离级别的实现.它没有物理结构,作用是事务执行期间用来定义"能看到什么数据".



####	快照在MVCC里是怎么工作的
在RR级别下,事务在启动的时候就"拍了个快照",这个快照是基于整库的,但并不是整库拷贝一份.来看下它是怎么实现的:

InnoDB里面每个事务有一个唯一的事务ID,叫做transaction id.它是在事务开始的时候向InnoDB的事务系统申请的,是按申请顺序严格递增的.

而每行数据也都是有多个版本的,每次事务更新数据的时候,都会生成一个新的数据版本,并且把transaction id赋值给这个数据版本的事务ID,记为 row trx_id.同时,旧的数据版本要保留,并且在新的数据版本中,能够有信息可以直接拿到它.也就是说,数据表中的一行记录,其实可能有多个版本(row),每个版本有自己的row trx_id.如下图所示,就是一个记录被多个事务连续更新后的状态.
![unaPwF.png](https://s2.ax1x.com/2019/09/26/unaPwF.png)

图中虚线框里是同一行数据的4个版本,当前最新版本是V4,k的值是22,它是被transaction id为25的事务更新的,因此它的row trx_id也是25.

前面基础篇有提到过undo log(回滚日志),那么undo log在哪呢?实际上,图中的三个虚线箭头,就是undo log;而V1,V2,V3并不是物理上真实存在的,而是每次需要的时候根据当前版本和undo log计算出来的.比如,需要V2的时候,就是通过V4依次执行U3,U2两个undo log算出来的.

而快照的生成就是,InnoDB为每个事务构造一个数组,用来保存这个事务启动瞬间,当前正在"活跃"的所有事务ID."活跃"指的就是,启动了但还没提交.

数组里面事务ID的最小值记为低水位,当前系统里面已经创建过的事务ID的最大值加1记为高水位.这个是图书组和高水位,就组成了当前事务的一致性视图.MySQL内部就是通过这个数组来判断可见性的.但这个逻辑比较复杂,人肉分析很麻烦.

可以用如下方式判断可见性:
1.	版本未提交,不可见;
2.	版本已提交,但是是在视图创建后提交的,不可见;
3.	版本已提交,而且是在视图创建前提交的,可见.

####	更新逻辑
如下图
![un6AYT.png](https://s2.ax1x.com/2019/09/26/un6AYT.png)
上图中,事务C在执行 set k=k+1 后,事务就提交了.而B是在执行完三天语句后,事务才提交,也就是说在B执行set k=k+1之前,C已经commit

事务B的视图数组是先生成的,之后事务C才提交,不是应该看不见(1,2)吗,怎么能算出(1,3)来?

是的,如果事务B在更新之前查询一次数据,这个查询返回的k的值确实是1.但是,当它要去更新数据的时候,就不能在历史版本上更新了,否则事务C的更新就丢失了.因此事务B此时的set k=k+1是在(1,2)的基础上进行的操作.

所以,这里有这样一条规则:更新数据都是先读后写的,而这个读,只能读当前的值,称为"当前读".这里我们提到一个概念,叫做当前读.其实,除了update语句外,select语句如果加锁,也是当前读.所以,如果把事务A的查询语句 select * from t where id = 1修改一下,加上lock in share mode或for update,也都可以读到最新版本,返回的k的值是3,下面两个select语句,就是分别加了读锁(S锁,共享锁)和写锁(X锁,排他锁).
```
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

<br>
<br>
再更进一步,假设事务C不是马上提交的,而是变成了下面的事务C,来看一下会是什么情况:
![uuDnAK.png](https://s2.ax1x.com/2019/09/27/uuDnAK.png)

事务C更新后没有马上提交,在它提交前,事务B的更新语句先发起了.虽然事务C还没提交,但是(1,2)这个版本已经生成了,并且是当前的最新版本.这时候,由于在MySQL锁篇中提到的"两阶段锁协议",事务C没提交,也就是说(1,2)这个版本的写锁还没释放.而事务B是当前读,必须要读最新版本,而且必须加锁,因此就被锁住了,必须要等到事务C释放这个锁,才能继续它的当前读.

至此,我们把一致性读,当前读和行锁就串起来了.

**事务的可重复读能力的实现,一句话总结就是:可重复读的核心就是一致性读;而事务更新数据的时候,只能用当前读.如果当前的记录的行锁被其他事务占用的话,就需要进入锁等待.**


####	读提交隔离级别下事务特性
读提交和可重复读的逻辑类似,他们的主要区别是:
*	在可重复读隔离级别下,只需要在事务开始的时候创建一致性视图,之后事务里的其他查询都共用这个一致性视图;
*	在读提交隔离级别下,每一个语句执行前都会重新算出一个新的视图.

下面来看一下,在读提交隔离级别下,事务A和事务B的查询语句查到的k,分别应该是多少:

这里先说明一下,"start transaction with consistent snapshot;"的意思是从这个语句开始,创建一个持续整个事务的一致性快照.所以,在读提交隔离级别下,这个用法就没意义了,等效于普通的start transaction.

下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组,就是图中的read view框:
![uuctfK.jpg](https://s2.ax1x.com/2019/09/27/uuctfK.jpg)

这时,事务A的查询语句的视图数组是在执行这个语句的时候创建的,时序上(1,2),(1,3)的生成时间都在创建这个视图数组的时刻之前.但是,在这个时刻:
*	(1,3)还没提交,不可见
*	(1,2)提交了,可见

所以,这时候事务A查询语句返回的是k=2;事务B查询结果k=3