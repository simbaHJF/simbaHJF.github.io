---
layout:     post
title:      "mysql锁"
date:       2019-09-23 17:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	全局锁
全局锁就是对整个数据库实例加锁.MySQL提供了一个加全局读锁的方法,命令是Flush tables with read lock(FTWRL).当需要让整个库处于只读状态的时候,可以使用这个命令,之后其他线程的以下语句会被阻塞:数据更新(数据的增删改),数据定义语句(包括建表,修改表结构等)和更新类事务的提交语句.

全局锁的典型使用场景是,做全库逻辑备份.但是让整库都只读,比较危险:

*	如果在主库上备份,那么在备份期间都不能执行更新,业务基本上就得停摆;
*	如果在从库上备份,那么备份期间从库不能执行主库同步过来的binlog,会导致主从延迟.

官方自带的逻辑备份工具是mysqldump.当mysqldump使用参数----single-transaction的时候,导数据之前就会启动一个事务,来确保拿到一致性视图.而由于MVCC的支持,这个过程中数据是可以正常更新的.
既然有了这个功能,为什么还需要FTWRL呢?一致性读是好,但前提是引擎要支持这个隔离级别.比如,对于MyISAM这种不支持事务的引擎,如果备份过程中有更新,总是只能取到最新的数据,那么就破坏了备份的一致性.这时,就需要使用FTWRL命令了.

所以,single-transaction方法只适用于所有的表使用事务的引擎.如果有的表使用了不支持事务的引擎,那么备份就只能通过FTWRL方法.这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一.



##	表级锁
MySQL里面表级别的锁有两种:

####	表锁
表锁的语法是lock tables ... read/write.可以用unlock tables主动释放锁,也可以在客户端断开的时候自动释放.lock tables语法除了会限制别的线程的读写外,也限定本线程接下来的操作对象.

举个例子,如果在某个线程A中执行lock tables t1 read,t2 write;这个语句,则其他线程写t1,读写t2的语句都会被阻塞.同时,线程A在执行unlock tables之前,也只能执行读t1,读写t2的操作.连写t1都不允许,自然也不能访问其他表.

在还没有出现更细粒度的锁的时候,表锁是最常用的处理并发的方式.而对于InnoDB这种支持行锁的引擎,一般不适用lock tables命令来控制并发,毕竟锁住整个表的影响面还是太大.

####	元数据锁(meta data lock,MDL)
MDL不需要显式使用,在访问一个表的时候会被自动加上.MDL的作用是,保证读写的正确性.在MySQL5.5版本中引入了MDL,当对一个表做增删改查操作时,加MDL读锁;当要对表做结构变更操作的时候,加MDL写锁.

*	对于MDL,读锁之间不互斥,因此可以有多个线程同时对一张表增删改查.
*	读写锁之间,写锁之间是互斥的,用来保证变更表结构操作的安全性.因此,如果有两个线程要同时给一个表加字段,其中一个要等另一个执行完才能开始执行.

看下面的操作序列,假设表t是一个小表:
![uenYzn.jpg](https://s2.ax1x.com/2019/09/25/uenYzn.jpg)

sessionA先启动,这时候会对表t加一个MDL读锁.由于sessionB需要的也是MDL读锁,因此可以正常执行.之后sessionC会被blocked,是因为sessionA的读锁还没有释放,而sessionC需要MDL写锁,因此只能被阻塞.如果只有sessionC自己被阻塞还没什么关系,但之后所有要在表t上新申请MDL读锁的请求也会被sessionC阻塞.前面讲,所有对表的增删改查操作都需要先申请MDL读锁,就都被锁住了,等于这个表现在完全不可读写了.

如果这个表上的查询语句频繁,而且客户端有重试机制,也就是说超时后会再起一个新session再请求的话,这个库的线程很快就会爆满.事务中的MDL锁,在语句执行开始时申请,但是语句结束后并不会马上释放,而会等到整个事务提交后再释放.




##	行级锁

MySQL的行锁是在引擎层由各个引擎自己实现的,但并不是所有的引擎都支持行锁,比如MyISAM引擎就不支持行锁.InnoDB是支持行锁的.

在InnoDB事务中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释放,而是要等到事务结束时才释放,这个就是两阶段锁协议.
根据这个协议,那么如果事务中需要锁多个行,要把最可能造成锁冲突,最可能影响并发度的锁尽量往后放.