---
layout:     post
title:      "mysql锁"
date:       2019-09-23 17:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	全局锁
全局锁就是对整个数据库实例加锁.MySQL提供了一个加全局读锁的方法,命令是Flush tables with read lock(FTWRL).当需要让整个库处于只读状态的时候,可以使用这个命令,之后其他线程的以下语句会被阻塞:数据更新(数据的增删改),数据定义语句(包括建表,修改表结构等)和更新类事务的提交语句.

全局锁的典型使用场景是,做全库逻辑备份.但是让整库都只读,比较危险:

*	如果在主库上备份,那么在备份期间都不能执行更新,业务基本上就得停摆;
*	如果在从库上备份,那么备份期间从库不能执行主库同步过来的binlog,会导致主从延迟.

官方自带的逻辑备份工具是mysqldump.当mysqldump使用参数----single-transaction的时候,导数据之前就会启动一个事务,来确保拿到一致性视图.而由于MVCC的支持,这个过程中数据是可以正常更新的.
既然有了这个功能,为什么还需要FTWRL呢?一致性读是好,但前提是引擎要支持这个隔离级别.比如,对于MyISAM这种不支持事务的引擎,如果备份过程中有更新,总是只能取到最新的数据,那么就破坏了备份的一致性.这时,就需要使用FTWRL命令了.

所以,single-transaction方法只适用于所有的表使用事务的引擎.如果有的表使用了不支持事务的引擎,那么备份就只能通过FTWRL方法.这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一.



##	表级锁
MySQL里面表级别的锁有两种:

####	表锁
表锁的语法是lock tables ... read/write.可以用unlock tables主动释放锁,也可以在客户端断开的时候自动释放.lock tables语法除了会限制别的线程的读写外,也限定本线程接下来的操作对象.

举个例子,如果在某个线程A中执行lock tables t1 read,t2 write;这个语句,则其他线程写t1,读写t2的语句都会被阻塞.同时,线程A在执行unlock tables之前,也只能执行读t1,读写t2的操作.连写t1都不允许,自然也不能访问其他表.

在还没有出现更细粒度的锁的时候,表锁是最常用的处理并发的方式.而对于InnoDB这种支持行锁的引擎,一般不适用lock tables命令来控制并发,毕竟锁住整个表的影响面还是太大.

####	元数据锁(meta data lock,MDL)
MDL不需要显式使用,在访问一个表的时候会被自动加上.MDL的作用是,保证读写的正确性.在MySQL5.5版本中引入了MDL,当对一个表做增删改查操作时,加MDL读锁;当要对表做结构变更操作的时候,加MDL写锁.

*	对于MDL,读锁之间不互斥,因此可以有多个线程同时对一张表增删改查.
*	读写锁之间,写锁之间是互斥的,用来保证变更表结构操作的安全性.因此,如果有两个线程要同时给一个表加字段,其中一个要等另一个执行完才能开始执行.

看下面的操作序列,假设表t是一个小表:
![uenYzn.jpg](https://s2.ax1x.com/2019/09/25/uenYzn.jpg)

sessionA先启动,这时候会对表t加一个MDL读锁.由于sessionB需要的也是MDL读锁,因此可以正常执行.之后sessionC会被blocked,是因为sessionA的读锁还没有释放,而sessionC需要MDL写锁,因此只能被阻塞.如果只有sessionC自己被阻塞还没什么关系,但之后所有要在表t上新申请MDL读锁的请求也会被sessionC阻塞.前面讲,所有对表的增删改查操作都需要先申请MDL读锁,就都被锁住了,等于这个表现在完全不可读写了.

如果这个表上的查询语句频繁,而且客户端有重试机制,也就是说超时后会再起一个新session再请求的话,这个库的线程很快就会爆满.事务中的MDL锁,在语句执行开始时申请,但是语句结束后并不会马上释放,而会等到整个事务提交后再释放.




##	行级锁

MySQL的行锁是在引擎层由各个引擎自己实现的,但并不是所有的引擎都支持行锁,比如MyISAM引擎就不支持行锁.InnoDB是支持行锁的.

在InnoDB事务中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释放,而是要等到事务结束时才释放,这个就是两阶段锁协议.
根据这个协议,那么如果事务中需要锁多个行,要把最可能造成锁冲突,最可能影响并发度的锁尽量往后放



##	InnoDB中的锁
在InnoDB中实现了两个标准的行级锁,可以简单的看做两个读写锁:
*	S-共享锁,又叫读锁,其他事务可以继续加共享锁,但是不能继续加排他锁.
*	X-排他锁,又叫写锁,一旦加了写锁之后,其他事务就不能加锁了.

. | X | S |
-|-|-|
X  | 冲突 | 冲突 |
S  | 冲突 | 兼容 |


在InnoDB中,事务的隔离级别为可重复读(REPEATABLE READ)下,InnoDB存储引擎的select操作使用一致性非锁定度.但是在某些情况下,用户需要显示地对数据库读取操作加锁以保证数据逻辑的一致性.InnoDB存储引擎对于select语句支持两种一致性的锁定读:
*	select ... for update对读取的行记录加一个X锁,其他事务不能对已锁定的行加上任何锁.
*	select ... lock in share mode对读取的行记录加一个S锁,其他事务可以向被锁定的行加S锁,但如果加X锁,则会被阻塞.

####	InnoDB锁算法

#####	记录锁(Record-Lock)
记录锁是锁住记录的,这里要说明的是这里锁住的是索引记录
*	如果锁的是非主键索引,会在自己的索引上面加锁之后然后再去主键上面加锁锁住.(这句话要分情况,锁普通索引如果加的是共享锁,然后查询可以根据覆盖索引得到结果的话,主键索引不会锁,后面讲的加锁原则第2条,也说明了这点;但是如果锁普通索引是用的for update加排它锁,就不一样了,会给主键索引也加上锁)
*	如果表上没有索引(包括没有主键索引),则会使用隐藏的主键索引进行加锁.
*	如果要锁的列没有索引,则会进行全表记录加锁

#####	间隙锁(Gap-Lock)
间隙锁顾名思义间隙锁,不锁记录,间隙锁的意思就是锁定某一个范围,间隙锁又叫gap锁,**其不会阻塞其他的gap锁,但是会阻塞间隙锁锁定范围的插入,这也是用来防止幻读的关键**.

#####	next-key锁
这个锁的本质是记录锁加上gap锁.在RR隔离级别下(InnoDB默认),InnoDB对于行的扫描锁定都是使用此算法,但是如果查询扫描中where条件是唯一索引会退化为只使用记录锁.因为唯一索引能确定行数,而普通索引不能确定行数,有可能在其他事务中会再次添加这个索引的数据造成幻读,所以普通索引的条件查询加锁仍是next-key锁.

**需要再次提醒的是,对于唯一索引的锁定,next-key lock降级为record lock仅存在于查询所有的唯一索引列.若唯一索引由多个列组成,而查询仅是查找唯一索引多个列中的某一个列,那么查询其实是range类型查询,而不是point类型查询,InnoDB此时仍然使用next-key lock进行锁定.**


####	加锁规则总结
两个"原则",两个"优化"和一个"bug"
*	原则1:	加锁的基本单位是next-key lock.next-key lock是前开后闭区间.
*	原则2:	查找过程中访问到的对象才会加锁.
*	优化1:	索引上的等值查询,给唯一索引加锁的时候,next-key lock退化为行锁.(针对唯一索引,且行记录存在)
*	优化2:	索引上的等值查询,向右遍历时且最后一个值不满足等值条件的时候,next-key lock退化为间隙锁.
*	一个bug:	唯一索引上的范围查询会访问到不满足条件的第一个值为止.


####	案例分析

*建表语句如下*
```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

```

#####	案例一:等值查询间隙锁
![uTrwpn.png](https://s2.ax1x.com/2019/10/10/uTrwpn.png)

表中没有id=7的记录.应用上述加锁规则:
*	根据原则1,加锁单位是next-key lock,session A加锁范围就是(5,10]
*	根据优化2,这是一个等值查询(id=7),而id=10不满足查询条件,next-key lock退化成间隙锁,因此最终加锁的范围是(5,10).

**所以,session B要往这个间隙里插入id=8的记录会被锁住,但是session C修改id=10这行是可以的.**

#####	案例二:非唯一索引等值锁
![uTRnD1.png](https://s2.ax1x.com/2019/10/10/uTRnD1.png)

*	根据原则1,加锁单位是next-key lock,因此会给(0,5]加上next-key lock.
*	要注意c是普通索引,因此仅访问到c=5这一条记录不能立即停止,需要向右遍历,查到c=10才放弃.根据原则2,访问到的都要加锁,因此要给(5,10]加next-key lock.
*	同时这个符合优化2:等值判断,向右遍历,最后一个值不满足c=5这个等值条件,因此退化成间隙锁(5,10).
*	根据原则2,只有访问到的对象才会加锁,这个查询使用了覆盖索引,并不需要访问主键索引,所以主键索引上没有加任何锁,这就是session B的update语句可以执行完成的原因.但是session C要插入一个(7,7,7)的记录,就会被session A的间隙锁(5,10)锁住.

**需要注意,这个例子中,lock in share mode只锁覆盖索引,但是如果是for update就不一样了.执行for update时,系统会认为接下来要更新数据,因此会顺便给主键索引上满足条件的行加上行锁,注意是主键索引上满足条件的行,比如这里session A的查询改为for update,则session B的更新语句将会阻塞,但是若将session B的更新语句改为update t set d = d + 1 where id = 10,那么就不会被阻塞.**

**这个例子说明,锁是加在索引上的;同时,如果要用lock in share mode来给行加读锁避免数据被更新的话,就必须得绕过覆盖索引的优化,比如在查询字段中加入索引中不存在的字段**

#####	案例三:主键索引范围锁
![uThTxg.png](https://s2.ax1x.com/2019/10/10/uThTxg.png)

*	开始执行的时候,要找到第一个id=10的行,因此本该是next-key lock(5,10].根据优化1,主键id上的等值条件,退化成行锁,只加了id=10这一行的行锁.
*	范围查找就往后继续找,找到id=15这一行停下,因此需要加next-key lock(10,15].**注意这时15这个点不会退化,优化2是针对等值查询的**

所以,session A这时候所得范围就是主键索引上,行锁id=10和next-key lock(10,15].这样,session B和session C的结果就可以理解了.

这里需要注意一点,首次session A定位查找id=10的行的时候,是当做等值查询来判断的,而向右扫描到id=15的时候,用的是范围查询判断.

#####	案例四:非唯一索引范围锁
![uHEhpq.png](https://s2.ax1x.com/2019/10/11/uHEhpq.png)

session A用字段c来判断,c是普通索引,在第一次用c=10定位记录的时候,索引c加上了(5,10]这个next-key lock后,由于索引c是非唯一的,没有优化规则,不会蜕变为行锁,因此最终session A加的锁是,索引c上的(5,10]和(10,15]这两个next-key lock.

所以从结果上看,session B要插入(8,8,8)的这个insert语句时就被堵住了.这里需要扫描到c=15才能停止.所以session C也被堵住.

#####	案例五:唯一索引范围锁bug
![uHm7x1.png](https://s2.ax1x.com/2019/10/11/uHm7x1.png)

session A是一个范围查询,按照原则1,应该是索引id上只加(10,15]这个next-key lock,并且因为id是唯一键,所以循环判断到id=15这一行就应该停止了.但是实现上,InnoDB会往前扫描到第一个不满足条件的行为止,也就是id=20.而且由于这是个范围扫描,因此索引id上的(15,20]这个next-key lock也会被锁上.所以session B要更新id=20这一行,是会被锁住的.同样,session C要插入id=16这一行,也会被锁住.照理说,这里锁住id=20这一行的行为,其实是没有必要的,因为扫描到id=15,就可以确定不用往后再找了.所以,把这点姑且先算做一个bug吧.

#####	案例六:非唯一索引上存在"等值"的例子
为了更好说明,这里,给表t插入一条新记录
```
insert into t values(30,10,30);
```

这次用delete语句来验证,delete语句的加锁逻辑,和select ... for update是一样的,如前所述的两个"原则",两个"优化",一个"bug".
![uHwNM6.png](https://s2.ax1x.com/2019/10/11/uHwNM6.png)

根据原则1和优化2,这个delete语句在索引c上的加锁范围,如下图蓝色区域覆盖的部分.蓝色区域左右两边都是虚线,表示开区间,即(c=5,id=5)和(c=15,id=15)这两行上都没有锁.
![uHwoJs.png](https://s2.ax1x.com/2019/10/11/uHwoJs.png)

#####	案例七:limit语句加锁(对照案例六)
![uHBaUe.png](https://s2.ax1x.com/2019/10/11/uHBaUe.png)

这个例子里,session A的delete语句加了limit 2.事先已经知道表t里c=10的记录其实只有两条,因此加不加limit 2的删除效果是一样的,但是加锁的效果却不同.可以看到,session B的insert语句执行通过了,跟案例六的结果不同.

这是因为,案例七里的delete语句明确加了limit 2的限制,因此在遍历到(c=10,id=30)这一行之后,满足条件的语句已经有两条,循环就结束了.因此,索引c上的加锁范围就变成了从(c=5,id=5)到(c=10,id=30)这个前开后闭区间,如下所示:
![uHD9r6.png](https://s2.ax1x.com/2019/10/11/uHD9r6.png)

可以看到,(c=10,id=30)之后的这个间隙并没有在加锁范围里,因此insert语句插入c=12是可以执行成功的.

这个例子对我们时间的指导意义就是,在删除数据的时候尽量加limit.这样不仅可以控制删除数据的条数,让操作更安全,还可以减小加锁的范围.

#####	案例八:一个死锁的例子
**这个案例的目的是说明:next-key lock实际上是间隙锁和行锁加起来的结果**

![uHf3nJ.png](https://s2.ax1x.com/2019/10/11/uHf3nJ.png)

*	session A启动事务后执行查询语句加lock in share mode,在索引c上加了next-key lock(5,10]和间隙锁(10,15);
*	session B的update语句也要在索引c上加锁(5,10]和间隙锁(10,15);
*	然后session A要再插入(8,8,8)这一行,被session B的间隙锁锁住.由于出现了死锁,InnoDB让session B回滚.

你可能会问,session B的next-key lock不是还没申请成功么?

事实上,session B的"加next-key lock(5,10]"操作,实际上分成了两步,先是加(5,10)的间隙锁,加锁成功(前面讲间隙锁定义的时候提到,它不会阻塞其他的gap锁,因此可以加锁成功);然后加c=10的行锁,这时候才被锁住的.

**也就是说,我们在分析加锁规则的时候可以用next-key lock来分析.但是要知道,具体执行的时候,是要分成间隙锁和行锁两段来执行的.**