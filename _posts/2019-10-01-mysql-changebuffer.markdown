---
layout:     post
title:      "mysql -- change buffer"
date:       2019-09-18 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记


##	change buffer
当需要更新一个数据页时,如果数据页在内存中就直接更新,而如果这个数据页还没有在内存中的话,在不影响数据一致性的前提下,InnoDB会将这些更新操作缓存在change buffer中,这样就不需要从磁盘中读入这个数据页了.在下次查询需要访问这个数据页的时候,将数据页读入内存,然后执行change buffer中与这个页有关的操作.通过这种方式就能保证这个数据逻辑的正确性.

change buffer实际上是可以持久化的数据.也就是说,change buffer在内存中有拷贝,也会被写入到磁盘上.

将change buffer中的操作应用到元数据页,得到最新结果的过程称为merge.除了访问这个数据页会触发merge外,系统有后台线程会定期merge.在数据库正常关闭(shutdown)的过程中也会执行merge操作.

显然,如果能够将更新操作先记录在change buffer,减少读磁盘,语句的执行速度会得到明显的提升.而且数据读入内存是需要占用buffer pool的,所以这种方式还能够避免占用内存,提高内存利用率.

**那么,什么条件下可以使用change buffer呢?**

对于唯一索引来说,所有的更新操作都要先判断这个操作是否违反唯一约束.比如,要插入(4,400)这个记录,就要先判断现在表中是否已经存在k=4的记录,而这必须要将数据页读入内存才能判断.如果都已经读入到内存了,那直接更新内存会更快,就没必要使用change buffer了.

因此,唯一索引的更新不能使用change buffer,实际上只有普通索引可以使用.

按照change buffer的机制,来看一下:如果要在表中插入一个新纪录(4,400)的话,InnoDB的处理流程是怎样的.

第一种情况是,这个记录要更新的目标页在内存中.这时,InnoDB的处理流程如下:
*	对于唯一索引来说,找到3和5之间的位置,判断到没有冲突,插入这个值,语句执行结束;
*	对于普通索引来说,找到3和5之间的位置,插入这个值,语句执行结束.

这样看来,普通索引和唯一索引对更新语句性能影响的差别,只是一个判断,只会消耗微小的CPU时间.因此,这不是我们关注的重点.

第二种情况是,这个记录要更新的目标页不在内存中.这时,InnoDB的处理流程如下:
*	对于唯一索引来说,需要将数据页读入内存,判断到没有冲突,插入这个值,语句执行结束;
*	对于普通索引来说,则是将更新记录在change buffer,语句执行就结束了.

将数据从磁盘读入内存设计随机IO的访问,是数据库里面成本最高的操作之一.change buffer因为减少了随机磁盘访问,所以对更新性能的提升很明显.