---
layout:     post
title:      "mysql -- flush脏页"
date:       2019-10-09 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	脏页和干净页
当内存数据页跟磁盘数据页内容不一致的时候,称这个内存页为"脏页".内存数据写入到磁盘后,内存和磁盘上的数据页的内容就一致了,称为"干净页".

##	flush场景

*	第一种场景是,InnoDB的redo log写满了.这时候系统会停止所有更新操作,把checkpoint往前推进,redo log留出空间可以继续写.checkpoint位置从CP推进到CP',就需要将两个点之间的日志(浅绿色部分),对应的所有脏页都flush到磁盘上.之后,图中从write pos到CP'之间就是可以再写入的redo log区域.见如下redo log状态示意图:
![u5iAyR.jpg](https://s2.ax1x.com/2019/10/09/u5iAyR.jpg)

*	第二种场景是,当需要新的内存页,而内存不够用时,就要淘汰一些数据页,空出内存给别的数据页使用.如果淘汰的是"脏页",就要先将脏页写到磁盘.
*	第三种场景是,MySQL认为系统"空闲"的时候.
*	第四种场景是,MySQL正常关闭的情况.

**下面来分析一下以上四种场景对性能的影响.**

其中,第三种情况是属于MySQL空闲时的操作,这时系统没什么压力,而第四种场景是数据库本来就要关闭了.这两种情况下不太需要关注性能问题,所以这里主要来分析一下前两种场景下的性能问题.

第一种是"redo log写满了,要flush脏页",这种情况是InnoDB要尽量避免的.因为出现这种情况的时候,整个系统就不能再接受更新了,所有的更新都必须堵住,从监控上看,这时更新数会跌为0.

第二种是"内存不够用了,要先将脏页写到磁盘",这种情况是常态.**InnoDB用缓冲池(buffer pool)管理内存,缓冲池中的内存页有三种状态:**
*	第一种是,还没有使用的;
*	第二种是,使用了并且是干净页;
*	第三种是,使用了并且是脏页.

InnoDB的策略是尽量使用内存,因此对于一个长时间运行的库来说,未被使用的页面很少.而当要读入的数据页没有在内存的时候,就必须到缓冲池中申请一个数据页.这时候会把最久不使用的数据页(LRU算法)从内存中淘汰掉:如果要淘汰的是一个干净页,就直接释放出来复用;但如果是脏页,就必须将脏页先刷到磁盘,变成干净页后才能复用.

**所以,刷脏页虽然是常态,但是出现以下两种情况,都是会明显影响性能的:**
*	一个查询要淘汰的脏页个数太多,会导致查询的响应时间明显边长;
*	日志写满,更新全部堵住,写性能跌为0,这种情况对敏感业务来说,是不能接受的.

##	InnoDB刷脏页的控制策略
首先,需要正确告诉InnoDB所在主机的IO能力,这样InnoDB才能知道需要全力刷脏页的时候,可以刷多快.这就用到innodb_io_capacity这个参数,它会告诉InnoDB磁盘能力.比如:MySQL写入速度很慢,TPS很低,但数据库主机IO压力并不大,就可能是因为这个参数设置过小的问题,导致磁盘IO能力未能发挥,进而影响了查询和更新的性能.


一旦一个查询请求需要再执行过程中先flush掉一个脏页时,这个查询就可能比平时慢了.而MySQL中的一个机制,可能让查询更慢:在刷一个脏页的时候,如果这个数据页旁边的数据页刚好也是脏页,就会吧这个相邻页带着一起flush;而这个逻辑可以继续蔓延,也就是对于每个相邻数据页,如果跟它相邻的数据页也还是脏页的话,也会被放到一起flush.

在InnoDB中,innodb_flush_neighbors参数就是用来控制这个行为的,值为1的时候会有上述的"连坐"机制,值为0时表示不找相邻页,只flush自己.

找相邻页的这个优化在机械硬盘时代是很有意义的,可以减少很多随机IO.机械硬盘的随机IOPS一般只有几百,相同的逻辑操作减少随机IO就意味着系统性能的大幅提升.
而如果使用的是SSD这类高IOPS设备的话,建议把innodb_flush_neighbors的值设置成0,因为这是IOPS往往不是瓶颈,而只刷自己,能更快的执行完必要的刷脏页操作,减少SQL语句响应时间.