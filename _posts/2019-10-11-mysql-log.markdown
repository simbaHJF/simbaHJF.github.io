---
layout:     post
title:      "mysql -- log"
date:       2019-10-11 22:50:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	redo log
redo log是InnoDB引擎特有的日志,InnoDB通过redo log来保证crash-safe.

redo log是物理日志,记录的是"在某个数据页上做了什么修改".

mysql进行update操作时,采用WAL(Write-Ahead Logging),即先写日志,再写磁盘.当有一条记录需要更新的时候,InnoDb引擎就会先把记录写到redo log里面,并更新内存,这个时候更新就算完成了.同时,InnoDB引擎会在适当的时候,将这个操作记录更新到磁盘里面,而这个更新往往是在系统比较闲的时候做.

InnoDB的redo log是固定大小的,比如可以配置为一组4个文件,每个文件的大小是1GB.从头开始写,写到末尾就又回到开头循环写.如下图所示:
![nHxQ0J.png](https://s2.ax1x.com/2019/09/18/nHxQ0J.png)
write pos是当前记录的位置,一边写以便后移,写到第3号文件末尾后就回到0号文件开头.checkpoint是当前要擦除的位置,也是往后推移并且循环的,擦除记录前要把记录更新到磁盘.


##	binlog
binlog是mysql的server层日志.最开始mysql没有InnoDB引擎,它的自带引擎是MyISAM,但是MyISAM没有crash-safe能力,binlog日志只能用于归档.

binlog是逻辑日志,记录的是这个语句的原始逻辑,比如"给ID=2这一行的c字段加1".

binlog是追加写入的,binlog文件写到一定大小后会切换到下一个,并不会覆盖以前的日志.

##	更新语句的执行过程
```
update T set c=c+1 where ID=2;
```

1.	执行器先找引擎取ID=2这一行.ID是主键,引擎直接用B+树搜索找到这一行.如果ID=2这一行所在的页本来就在内存中,就直接返回给执行器;否则,需要从磁盘读入内存,然后再返回.
2.	执行器拿到引擎给的行数据,把这个值加上1,比如原来是N,现在就是N+1,得到新的一行数据,再调用引擎接口写入这行新数据.
3.	引擎将这行新数据更新到内存中,同时将这个更新操作记录到redo log里面,此时redo log处于prepare状态.然后告知执行器执行完成了,随时可以提交事务.
4.	执行器生成这个操作的binlog,并把binlog写入磁盘.
5.	执行器调用引擎的提交事务接口,引擎把刚刚写入的redo log改成提交(commit)状态,更新完成.

下面是这个update语句的执行流程图,图中浅色框表示是在InnoDB内部执行的,深色框表示是在执行器中执行的:
![nbCiid.png](https://s2.ax1x.com/2019/09/19/nbCiid.png)

上述执行过程将redo log的写入拆成了两个步骤:prepare和commit,这就是"两阶段提交".


##	怎样让数据库恢复到半个月内任意一秒的状态
当需要恢复到指定的某一秒时,比如某天下午两点发现中午十二点有一次误删表,需要找回数据,那么可以这么做:
*	首先找到最近的一次全量备份,从这个备份恢复到临时库
*	然后,从备份的时间点开始,将备份的binlog依次取出来,重放到中午误删表之前的那个时刻.


##	binlog的写入机制
事务执行过程中,先把日志铣刀binlog cache,事务提交的时候,再把binlog cache写到binlog文件中.一个事务的binlog是不能被拆开的,因此不论这个事务多大,也要确保一次性写入.这就涉及到了binlog cache的保存问题.系统给binlog cache分配了一片内存,每个线程一个,参数binlog_cache_size用于控制单个县城内binlog cache所占内存的大小.如果超过了这个参数规定的大小,就要暂存到磁盘.

事务提交的时候,执行器把binlog cache里的完整事务写到binlog中,并清空binlog cache.状态如图1所示:
![uL9HgK.png](https://s2.ax1x.com/2019/10/11/uL9HgK.png)

每个线程有自己的binlog cache,但是共用同一份binlog文件.
*	图中的write,指的是把日志吸入到文件系统的page cache,并没有把数据持久化到磁盘,所以速度比较快.
*	图中的fsync,才是将数据持久化到磁盘的操作.一般情况下我们任务fsync才占磁盘的IOPS.

write和fsync的时机,是由参数sync_binlog控制的:
*	sync_binlog=0的时候,表示每次提交事务都只write,不fsync;
*	sync_binlog=1的时候,表示每次提交事务都会执行fsync;
*	sync_binlog=N(N>1)的时候,表示每次提交事务都write,但积累N个事务后才fsync.

因此,在出现IO瓶颈的场景里,将sync_binlog设置成一个比较大的值,可以提升性能.在实际的业务场景中,考虑到丢失日志量的可控性,一般不建议将这个参数设成0,比较常见的是将其设置为100~1000中的某个值.但是将sync_binlog设置为N,对应的风险是:如果主机发生异常重启,会丢失最近N个事务的binlog日志.所以,在即使主机宕机,也不允许发生事务丢失的场景下,该参数应当设置为1.


##	redo log的写入机制
