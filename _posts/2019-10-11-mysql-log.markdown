---
layout:     post
title:      "mysql -- log"
date:       2019-10-11 22:50:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记

##	redo log
redo log是InnoDB引擎特有的日志,InnoDB通过redo log来保证crash-safe.

redo log是物理日志,记录的是"在某个数据页上做了什么修改".

mysql进行update操作时,采用WAL(Write-Ahead Logging),即先写日志,再写磁盘.当有一条记录需要更新的时候,InnoDb引擎就会先把记录写到redo log里面,并更新内存,这个时候更新就算完成了.同时,InnoDB引擎会在适当的时候,将这个操作记录更新到磁盘里面,而这个更新往往是在系统比较闲的时候做.

InnoDB的redo log是固定大小的,比如可以配置为一组4个文件,每个文件的大小是1GB.从头开始写,写到末尾就又回到开头循环写.如下图所示:
![nHxQ0J.png](https://s2.ax1x.com/2019/09/18/nHxQ0J.png)
write pos是当前记录的位置,一边写以便后移,写到第3号文件末尾后就回到0号文件开头.checkpoint是当前要擦除的位置,也是往后推移并且循环的,擦除记录前要把记录更新到磁盘.


##	binlog
binlog是mysql的server层日志.最开始mysql没有InnoDB引擎,它的自带引擎是MyISAM,但是MyISAM没有crash-safe能力,binlog日志只能用于归档.

binlog是逻辑日志,记录的是这个语句的原始逻辑,比如"给ID=2这一行的c字段加1".

binlog是追加写入的,binlog文件写到一定大小后会切换到下一个,并不会覆盖以前的日志.

##	更新语句的执行过程
```
update T set c=c+1 where ID=2;
```

1.	执行器先找引擎取ID=2这一行.ID是主键,引擎直接用B+树搜索找到这一行.如果ID=2这一行所在的页本来就在内存中,就直接返回给执行器;否则,需要从磁盘读入内存,然后再返回.
2.	执行器拿到引擎给的行数据,把这个值加上1,比如原来是N,现在就是N+1,得到新的一行数据,再调用引擎接口写入这行新数据.
3.	引擎将这行新数据更新到内存中,同时将这个更新操作记录到redo log里面,此时redo log处于prepare状态.然后告知执行器执行完成了,随时可以提交事务.
4.	执行器生成这个操作的binlog,并把binlog写入磁盘.
5.	执行器调用引擎的提交事务接口,引擎把刚刚写入的redo log改成提交(commit)状态,更新完成.

下面是这个update语句的执行流程图,图中浅色框表示是在InnoDB内部执行的,深色框表示是在执行器中执行的:
![nbCiid.png](https://s2.ax1x.com/2019/09/19/nbCiid.png)

上述执行过程将redo log的写入拆成了两个步骤:prepare和commit,这就是"两阶段提交".


##	怎样让数据库恢复到半个月内任意一秒的状态
当需要恢复到指定的某一秒时,比如某天下午两点发现中午十二点有一次误删表,需要找回数据,那么可以这么做:
*	首先找到最近的一次全量备份,从这个备份恢复到临时库
*	然后,从备份的时间点开始,将备份的binlog依次取出来,重放到中午误删表之前的那个时刻.


##	binlog的写入机制
事务执行过程中,先把日志铣刀binlog cache,事务提交的时候,再把binlog cache写到binlog文件中.一个事务的binlog是不能被拆开的,因此不论这个事务多大,也要确保一次性写入.这就涉及到了binlog cache的保存问题.系统给binlog cache分配了一片内存,每个线程一个,参数binlog_cache_size用于控制单个县城内binlog cache所占内存的大小.如果超过了这个参数规定的大小,就要暂存到磁盘.

事务提交的时候,执行器把binlog cache里的完整事务写到binlog中,并清空binlog cache.状态如图1所示:
![uL9HgK.png](https://s2.ax1x.com/2019/10/11/uL9HgK.png)

每个线程有自己的binlog cache,但是共用同一份binlog文件.
*	图中的write,指的是把日志吸入到文件系统的page cache,并没有把数据持久化到磁盘,所以速度比较快.
*	图中的fsync,才是将数据持久化到磁盘的操作.一般情况下我们任务fsync才占磁盘的IOPS.

write和fsync的时机,是由参数sync_binlog控制的:
*	sync_binlog=0的时候,表示每次提交事务都只write,不fsync;
*	sync_binlog=1的时候,表示每次提交事务都会执行fsync;
*	sync_binlog=N(N>1)的时候,表示每次提交事务都write,但积累N个事务后才fsync.

因此,在出现IO瓶颈的场景里,将sync_binlog设置成一个比较大的值,可以提升性能.在实际的业务场景中,考虑到丢失日志量的可控性,一般不建议将这个参数设成0,比较常见的是将其设置为100~1000中的某个值.但是将sync_binlog设置为N,对应的风险是:如果主机发生异常重启,会丢失最近N个事务的binlog日志.所以,在即使主机宕机,也不允许发生事务丢失的场景下,该参数应当设置为1.


##	redo log的写入机制
事务在执行过程中,生成的redo log是要先写道redo log buffer的.事务还没提交的时候,redo log buffer中的部分日志有没有可能被持久化到磁盘呢?  答案是,确实会有.

这个问题,要从redo log可能存在的三种状态说起.这三种状态,对应的就是下图三个色块.
![uLcgkq.png](https://s2.ax1x.com/2019/10/12/uLcgkq.png)
这三种状态分别是:
*	存在redo log buffer中,物理上是MySQL进程内存中,就是图中的红色部分;
*	写到磁盘(write),但是没有持久化(fsync),物理上是在文件系统的page cache里面,也就是图中的黄色部分;
*	持久化到磁盘,对应的是hard disk,也就是图中的绿色部分.

日志写道redo log buffer是很快的,write到page cache也差不多,但是持久化到磁盘的速度就慢多了.

为了控制redo log buffer的写入策略,InnoDB提供了innodb_flush_log_at_trx_commit参数,它有三种可能取值:
*	设置为0的时候,表示每次事务提交时都只是把redo log留在redo log buffer中;
*	设置为1的时候,表示每次事务提交时都将redo log直接持久化到磁盘;
*	设置为2的时候,表示每次事务提交时都只是把redo log写道page cache.

InnoDB有一个后台线程,每隔1秒,就会把redo log buffer中的日志,调用write写到文件系统的page cache,然后调用fsync持久化到磁盘.

事务执行中间过程的redo log也是直接卸载redo log buffer中的,这些redo log也会被后台线程一起持久化到磁盘.也就是说,一个没有提交的事务的redo log,也是可能已经持久化到磁盘的.

前面介绍两阶段提交的时候说过,时序上redo log先prepare,再写binlog,最后再把redo log commit.如果把innodb_flush_log_at_trx_commit设置成1,那么redo log在prepare阶段就要持久化一次,因为有一个崩溃回复逻辑是要依赖于prepare的redo log,再加上binlog来恢复的.

每秒一次后台轮询刷盘,再加上崩溃恢复这个逻辑,InnoDB就认为redo log在commit的时候就不需要fsync了,只会write到文件系统的page cache中就够了.

通常我们说MySQL的"双1"配置,指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成1.也就是说,一个事务完整提交前,需要等待两次刷盘,一次是redo log(prepare阶段),一次是binlog.