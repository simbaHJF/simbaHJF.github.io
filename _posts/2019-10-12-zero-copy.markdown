---
layout:     post
title:      "零拷贝"
date:       2019-10-12 14:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

> 转:石杉的架构笔记


##	零拷贝(Zero-copy)简介

零拷贝(Zero-copy)技术指在计算机执行操作时,CPU不需要先将数据从一个内存区域复制到另一个内存区域,从而可以减少上下文切换以及CPU的拷贝时间.

它的作用是在数据报从网络设备到用户程序空间传递的过程中,减少数据拷贝次数,减少系统调用,实现CPU的零参与,彻底消除CPU在这方面的负载.

实现零拷贝用到的最主要技术是DMA数据传输技术和内存区域映射技术:
*	零拷贝机制可以减少数据在内核缓冲区和用户进程缓冲区之间反复的I/O拷贝操作.
*	零拷贝机制可以减少用户进程地址空间和内核地址空间之间因为上下文切换而带来的CPU开销.


##	物理内存和虚拟内存

####	物理内存

物理内存(Physical Memory)是相对于虚拟内存(Virtual Memory)而言的.物理内存指通过物理内存条而获得的内存空间;而虚拟内存则是划分的一块虚拟的区域.内存主要作用是在计算机运行时为操作系统和各种程序提供临时储存.

####	虚拟内存

虚拟内存是计算机系统内存管理的一种技术.它使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间).而实际上,虚拟内存通常是被分割成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换,加载到物理内存中来.

虚拟内存地址和用户进程紧密相关,一般来说不同进程里的同一个虚拟地址指向的物理地址是不一样的,所以离开进程谈虚拟内存没有任何意义.每个进程所能使用的虚拟地址大小和CPU位数有关.虚拟地址空间又分为内核空间和用户空间两部分.32位系统的内核空间占用1G,位于高位,剩下的3G是用户空间.而64位系统的内核空间和用户空间都是128T,分别占据整个内存空间的最高处和最低处,剩下的中间部分是未定义的.而实际的物理内存可能远远小于虚拟内存的大小.

每个用户进程维护了一个单独的页表(Page Table),虚拟内存和物理内存就是通过这个页表实现地址空间的映射的.

下面给出两个进程A,B各自的虚拟内存空间以及对应的物理内存之间的地址映射示意图:
![uOhyZD.png](https://s2.ax1x.com/2019/10/12/uOhyZD.png)

当进程执行一个程序时,需要先从内存中读取该进程的指令,然后执行,获取指令时用到的就是虚拟地址.这个虚拟地址是程序链接时确定的(内核加载并初始化进程时会调整动态库的地址范围).

为了获取到实际的数据,CPU需要将虚拟地址转换成物理地址,CPU转换地址时需要用到进程的页表(Page Table),而页表(Page Table)里面的数据由操作系统维护.页表(Page Table)维护着内存映射(Memory Mapping),里面的每个内存映射都将一块虚拟地址映射到一个特定的地址空间(物理内存或者磁盘存储空间).每个进程都拥有自己的页表(Page Table),和其他进程的页表(Page Table)没有关系.

<font color="red">通过上面的介绍,可以简单的将用户进程申请并访问物理内存(或磁盘存储空间)的过程总结如下:</font>
*	用户进程向操作系统发出内存申请请求.
*	系统会检查进程的虚拟地址空间是否被用完,如果有剩余,给进程分配虚拟地址.
*	系统为这块虚拟地址创建内存映射(Memory Mapping),并将它放进该进程的页表(Page Table)
*	系统返回虚拟地址给用户进程,用户进程开始访问该虚拟地址.
*	CPU根据虚拟地址在此进程的页表(Page Table)中找到了相应的内存映射(Memory Mapping),但是这个内存映射没有和物理内存关联,于是产生了缺页中断.
*	操作系统收到缺页中断后,分配真正的物理内存并将它关联到页表相应的内存映射.中断处理完成后,CPU就可以访问内存了.
*	当然缺页中断不是每次都会发生,只有系统觉得有必要延迟分配内存的时候才用得着,也即很多时候,在上面的第3步系统就会分配真正的物理内存并和内存映射进行关联.

<font color="red">在用户进程和物理内存(磁盘存储器)之间引入虚拟内存主要有以下的有点:</font>
*	地址空间:	提供更大的地址空间,并且地址空间是连续的,使得程序编写,链接更加简单.
*	进程隔离:	不同进程的虚拟地址之间没有关系,所以一个进程的操作不会对其他进程造成影响.
*	数据保护:	每块虚拟内存都有相应的读写属性,这样就能保护程序的代码段不被修改,数据块不能被执行等,增加了系统的安全性.
*	内存映射:	有了虚拟内存之后,可以直接映射磁盘上的文件(可执行文件或动态库)到虚拟地址空间.

	这样可以做到物理内存延时分配,只有在需要读相应的文件的时候,才将它真正的从磁盘上加载到内存中来,而在内存吃紧的时候又可以将这部分内存清空掉,提高物理内存利用效率,并且所有这些对应用程序都是透明的.
*	共享内存:	比如动态库只需要在内存中存储一份,然后将它映射到不同进程的虚拟地址空间中,让进程觉得自己独占了这个文件.

	进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享.
*	物理内存管理:	物理地址空间全部由操作系统管理,进程无法直接分配和回收,从而系统可以更好的利用内存,平衡进程间对内存的需求.


##	内核空间和用户空间
操作系统的核心是内核,独立于普通的应用程序,可以访问受保护的内存空间,也有访问底层硬件设备的权限.为了避免用户进程直接操作内核,保证内核安全,操作系统将虚拟内存划分为两部分,一部分是内核空间(Kernel-space),一部分是用户空间(User-space).

在Linux系统中,内核模块运行在内核空间,对应的进程处于内核态;而用户程序运行在用户空间,对应的进程处于用户态.Linux32位系统的寻址空间(虚拟存储空间)为4G(2^32),将最高的1G的字节(从虚拟地址0xC0000000到0xFFFFFFFF)供内核进程使用,称为内核空间;较低的3G字节(从虚拟地址0x00000000到0xBFFFFFFF),供各个用户进程使用,称为用户空间.

下图是一个进程的用户空间和内核空间的内存布局:
![uzfGl9.png](https://s2.ax1x.com/2019/10/14/uzfGl9.png)

####	内核空间
内核空间总是驻留在内存中,它是为操作系统和的内核保留的.应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数的.

上图左侧区域为内核进程对应的虚拟内存,按访问权限可以分为进程私有和进程共享两块区域:
*	进程私有的虚拟内存:每个进程都有单独的内核栈,页表,task结构以及mem_map结构等.
*	进程共享的虚拟内存:属于所有进程共享的内存区域,包括物理存储器,内核数据和内核代码区域.

####	用户空间
每个普通的用户进程都有一个单独的用户空间,处于用户态的进程不能访问内核空间中的数据,也不能直接调用内核函数,因此要进行系统调用的时候,就要将进程切换到内核态才行.用户空间包括以下几个内存区域:
*	运行时栈:有编译器自动释放,存放函数的参数值,局部变量和方法返回值等.每当一个函数被调用时,该函数的返回类型和一些调用的信息被存储到栈顶,调用结束后调用信息会被弹出并释放掉内存.
栈区是从高地址位向低地址位增长的,是一块连续的内存区域,最大容量是由系统预先定义好的,申请的栈空间超过这个界限时会提示溢出.
*	运行时堆:用于存放进程运行中被动态分配的内存段,位于BBS和栈中间的地址位.由开发人员申请分配(malloc)和释放(free).堆是从低地址位向高低职位增长,采用链式存储结构.
频繁地malloc/free造成内存空间的不连续,产生大量碎片.当申请堆空间时,库函数按照一定的算法搜索可用的足够大的空间.因此堆的效率比栈要低得多.
*	代码段:存放CPU可以执行的机器指令,该部分内存只能读不能写.通常代码区是共享的,即其他执行程序可以调用它.
*	未初始化的数据段:存放未初始化的全局变量,BSS的数据在程序开始执行之前被初始化为0或NULL.
*	已初始化的数据段:存放已初始化的全局变量,包括静态全局变量,静态局部变量以及常量.
*	内存映射区域:例如将动态库,共享内存等虚拟空间的内存映射到物理空间的内存,一般是mmap函数锁分配的虚拟内存空间.

