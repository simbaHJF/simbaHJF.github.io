---
layout:     post
title:      "消息队列--消息模型"
date:       2019-10-25 14:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - MQ

---

> 极客时间--李玥--消息队列高手课 学习笔记

##	队列和主题的区别(生产消费模型和发布订阅模型)

早期的消息队列,是按照"队列"的数据结构来设计的.生产者(Producer)发消息就是入队操作,消费者(Consumer)收消息就是出队也就是删除操作,服务端存放消息的容器自然就称为"队列".

这就是最初的一种消息模型:队列模型(生产消费)
![KaX7CQ.jpg](https://s2.ax1x.com/2019/10/25/KaX7CQ.jpg)

如果有多个消费者接收同一个队列的消息,这些消费者之间实际上是竞争的关系,每个消费者只能收到队列中的一部分消息,也就是说任何一条消息只能被其中的一个消费者收到.如果需要将一份消息数据分发给多个消费者,要求每个消费者都能收到全量的消息,这个时候,单个队列就无法满足需求,一个可行的解决方式是,为每个消费者创建一个单独的队列,让生产者发送多份.

显然这是个比较蠢的做法,同样的一份消息数据被复制到多个队列中会浪费资源,更重要的是,生产者必须知道有多少个消费者.为每个消费者单独发送一份消息,这实际上违背了消息队列"解耦"这个设计初衷.

为解决这个问题,演化出另外一种消息模型:发布-订阅模型(主题)
![KavXkT.jpg](https://s2.ax1x.com/2019/10/25/KavXkT.jpg)

在发布-订阅模型中,消息的发送方称为发布者(Publisher),消息的接收方称为订阅者(Subscriber),服务端存放消息的容器称为主题(Topic).发布者将消息发送到主题中,订阅者在接收消息之前需要先"订阅主题".

队列模式(生产消费模型)和主题模式(发布-订阅模型),本质上是类似的,他们最大的区别其实就是,一份消息数据能不能被消费多次的问题.


##	RocketMQ的消息模型

RocketMQ使用的消息模型是标准的发布-订阅模型,在RocketMQ的术语表中,生产者,消费者和主题与上面讲的发布-订阅模型中的概念是完全一样的.但是,在RocketMQ中也有队列(Queue)这个概念,并且队列在RocketMQ中是一个非常重要的概念.队列在RocketMQ中的作用,要从消息队列的消费机制说起.

几乎所有的消息队列产品都是用一种"请求-确认"机制,确保消息不会在传递过程中由于网络或服务器故障丢失.在生产端,生产者先将消息发送给服务端,也就是Broker,服务端在收到消息并将消息写入主题或者队列中后,会给生产者发送确认的响应.

如果生产者没有收到服务端的确认或者收到失败的响应,则会重新发送消息;在消费端,消费者在收到消息并完成自己的消费业务逻辑后,也会给服务端发送消费成功的确认,服务端只有收到消费确认后,才认为一条消息被成功消费,否则他会给消费者重新发送这条消息,直到收到对应的消费成功确认.

这个确认机制很好地保证了消息传递过程中的可靠性,但是,引入这个机制在消费端带来了一个问题是:为了确保消息的有序性,在某一条消息被成功消费之前,下一条消息是不能被消费的,否则就会出现消息空洞,违背了有序性这个原则.也就是说,每个主题在任意时刻,之多只能有一个消费者示例在进行消费,那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能.为了解决这个问题,RocketMQ在主题下面增加了队列的概念.

每个主题包含多个队列,通过多个队列来实现多实例并行生产和消费.需要注意的是,RocketMQ只在队列上保证消息的有序性,主题层面是无法保证消息的严格顺序的.

RocketMQ中,订阅者的概念是通过消费组(Consumer Group)来体现的.每个消费组都消费主题中一份完整的消息,不同消费组之间消费进度彼此不受影响,也就是说,一条消息被Consumer Group1消费国,也会再给Consumer Group2消费.

消费组中包含多个消费者,同一个组内的消费者是竞争消费的关系,每个消费者负责消费组内的一部分消息.如果一条消息被消费者Consumer1消费了,那同组的其他消费者就不会再收到这条消息.

在Topic的消费过程中由于消息需要被不同的组进行多次消费,所以消费完的消息并不会立即被删除,这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置(Consumer Offset),这个位置之前的消息都被消费过,之后的消息都没有被消费过,每成功消费一条消息,消费位置就加一.这个消费位置是非常重要的概念,我们在使用消息队列的时候,丢消息的原因大多是由于消费位置处理不当导致的.

RocketMQ的消息模型中了比较关键的概念就是这些.为了便于理解,可以参考下图:
![Kd22Ax.jpg](https://s2.ax1x.com/2019/10/25/Kd22Ax.jpg)


##	Kafka的消息模型
另一种消息队列Kafka,Kafka的消息模型和RocketMQ是完全一样的,RocketMQ中对应的概念,和生产消费过程中的确认机制,都完全适用于Kafka.唯一区别是,在Kafka中,队列这个概念的名称不一样,Kafka中对应的名称是"分区(Partition)",含义和功能是没有任何区别的.