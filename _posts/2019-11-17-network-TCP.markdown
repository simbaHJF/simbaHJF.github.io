---
layout:     post
title:      "TCP"
date:       2019-11-17 16:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 网络

---

> 计算机网络--谢希仁

#	TCP概述

##	TCP主要特点

1.	TCP是面向连接的运输层协议.应用程序在使用TCP协议之前,必须先建立TCP连接.在传送数据完毕后,必须释放已经建立的TCP连接.
2.	每一条TCP连接只能有两个端点,每一条TCP连接只能是点对点的.
3.	TCP提供可靠交付的服务.通过TCP连接传送的数据,无差错,不丢失,不重复,并且按序到达.
4.	TCP提供全双工通信.TCP允许通信双方的应用进程在任何时候都能发送数据.TCP连接的两端都设有发送缓存和接收缓存,用来临时存放双向通信的数据.在发送时,应用程序在把数据传送给TCP的缓存后,就可以做自己的事,而TCP在合适的时候把数据发送出去.在接收时,TCP把收到的数据放入缓存,上层的应用进程在合适的时候读取缓存中的数据.
5.	面向字节流.TCP中的"流"指的是流入到进程或从进程流出的字节序列."面向字节流"的含义是:虽然应用程序和TCP的交互时一次一个数据块(大小不等),但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流.TCP并不知道所传送的字节流的含义.TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系(例如,发送方应用程序交给发送方的TCP共10个数据块,但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序).但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样.当然,接收方的应用程序必须有能力识别收到的字节流,把它还原成有意义的应用层数据.

**注:**

*	TCP连接是一条虚连接(也就是逻辑连接),而不是一条真正的物理连接.TCP报文先要传送到IP层,加上IP首部后,再传送到数据链路层.再加上数据链路层的首部和尾部后,才离开主机发送到物理链路.
*	TCP不关心应用进程一次把多长的报文发送到TCP的缓存中,而是根据对方给出的窗口值和当前网络拥塞的成都来决定一个报文段应包含多少字节.如果应用进程传送到TCP缓存的数据块太长,TCP就可以把它划分短一些再传送.如果应用进程一次只发来一个字节,TCP也可以等待积累有足够多的字节后再构成报文段发送出去.


##	TCP的连接

TCP把连接作为最基本的抽象,每一条TCP连接有两个端点.TCP连接的端点叫做套接字(socket).

套接字 socket = (IP地址 : 端口号)

每一条TCP连接唯一地被通信两段的两个端点(即两个套接字)所确定.即:<br>
TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}


##	停止等待协议

每发送完一个分组就停止发送,等待对方的确认,在收到确认后再发送下一个分组

1.	无差错情况
![MrcQMj.png](https://s2.ax1x.com/2019/11/17/MrcQMj.png)

2.	出现差错<br>
差错报文或报文在传输过程中丢失
![Mrc0y9.png](https://s2.ax1x.com/2019/11/17/Mrc0y9.png)

3.	确认丢失和确认迟到<br>
*	B所发送的对M1的确认丢失了,A在设定的超时重传时间内未收到确认,并无法知道是自己发送的分组出错,丢失或者是B发送的确认丢失了,因此A在超时后就要重传M1.假定B又收到了重传的分组M1,将采取两个行动.<br>
第一,丢弃这个重复的分组M1,不向上层交付.<br>
第二,向A发送确认.不能认为已经发送过确认就不再发送,因为A之所以重传M1就表示A没有收到对M1的确认
![MrgrcQ.png](https://s2.ax1x.com/2019/11/17/MrgrcQ.png)
*	传输过程中没有出现差错,但B对分组M1的确认迟到了.A会收到重复的确认.对重复的确认的处理很简单:收下后就丢弃.B仍然会收到重复的M1,并且同样要丢弃重复的M1,并且重传确认分组
![Mr4S0J.png](https://s2.ax1x.com/2019/11/17/Mr4S0J.png)

**停止等待协议的优点是简单,缺点是信道利用率太低**


##	连续ARQ协议

[![MrOVPg.md.png](https://s2.ax1x.com/2019/11/17/MrOVPg.md.png)](https://imgchr.com/i/MrOVPg)

图中,发送方维持的发送窗口,它的意义是:位于发送窗口内的5个分组都可连续发送出去,而不需要等待对方的确认.这样,信道的利用率就提高了.

连续ARQ协议规定,发送方每收到一个确认,就把发送窗口向前华东一个分组的位置.图b表示发送方收到了对第1个分组的确认,于是把发送窗口向前移动了一个分组的位置,如果原来已经发送了前5个分组,那么现在就可以发送窗口内的第6个分组了.

接收方一般都是采用累积确认的方式.这就是说,接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认,这就表示:到这个分组位置的所有分组都已正确的收到了.

累积确认有优点也有缺点.优点是:容易实现,即使确认丢失也不必重传.但缺点是不能向发送方反映出接收方已经正确收到的所有分组信息.

例如,如果发送方发送了前5个分组,而中间的第3个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都重传一次.这就叫做 Go-back-N(回退N) ,表示需要再退回来重传已发送过的N个分组.可见当通信线路质量不好时,连续ARQ协议会带来负面的影响.


##	TCP报文段的首部格式

TCP传送的数据单元是报文.一个TCP报文段分为首部和数据两部分.TCP报文段首部的前20个字节是固定的,后面有4n字节是根据需要而增加的选项(n是整数).因此TCP首部的最小长度是20字节.
![MsAEgx.png](https://s2.ax1x.com/2019/11/17/MsAEgx.png)

首部固定部分个字段意义如下:

1.	源端口和目的端口	各占2个字节,分别写入源端口号和目的端口号.
2.	序号	占4字节.序号范围是[0,2^32 -1],超过2^32-1后,下一个序号又回到0,也就是说,序号使用mod 2^32运算.在一个TCP连接中传送的字节流中的每一个字节都按顺序编号.整个要传送的字节流的起始序号必须在连接建立时设置.首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号.<br>
例如,一个报文段的序号字段值是301,而携带的数据共有100字节.这就表明:本报文段的数据的第一个字节的序号是301,最后一个字节的序号是400.显然,下一个报文段(如果还有的话)的数据序号应当从401开始,即下一个报文段的序号字段值应为401.
3.	确认号	占4字节,是**期望收到对方下一个报文段的第一个数据字节的序号**.<br>
例如,B正确收到了A发送过来的一个报文段,其序号字段值是501,而数据长度是200字节(序号501~700),这表明B正确收到了A发送的直到序号700为止的数据.因此,B期望收到A的下一个数据序号是701,于是B在发送给A的确认报文段中把确认号置为701.**<font color="red">注意,现在的确认号不是501,也不是700,而是701</font>**<br>
总之,应当记住:	若确认号 = N, 则表明:	到序号N - 1 位置的所有数据都已正确收到.
4.	数据偏移	占4位,它之处TCP报文段的数据起始处距离TCP报文段的起始处有多远.这个字段实际上是指出TCP报文段的首部长度.由于首部中还有长度不确定的选项字段,因此数据偏移字段是必要的."数据偏移"的单位是32位字,4位二进制数能表示的最大十进制数字是15,因此数据偏移的最大值是60字节,这也是TCP首部的最大长度.
5.	保留	占6位,保留为今后使用,但目前应置为0.
6.	紧急URG(URGent)	当URG=1时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据),而不要按原来的排队顺序来传送.
7.	确认ACK	仅当ACK=1时确认号字段才有效.当ACK=0时,确认号无效.TCP规定,在连接建立后所有传送的报文段都必须把ACK置为1.
8.	推送PSH	当两个应用进程进行交互通信时,有时在一端的应用进程希望在键入一个命令后就立即能够收到对方的响应.在这种情况下,TCP就可以使用推送操作.这时,发送方TCP把PSH置1,并立即创建一个报文段发送出去.接收方TCP收到PSH=1的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付.虽然应用程序可以选择推送操作,但推送操作很少使用.
9.	复位RST	当RST=1时,表明TCP连接中出现严重差错,必须释放连接,然后再重新建立运输连接.RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接.RST也可称为重建为或重置位.
10.	同步SYN	在连接建立时用来同步序号.当SYN=1而ACK=0时,表明这是一个连接请求报文段.对方若同意建立连接,则应在响应的报文段中使SYN=1和ACK=1.因此,SYN置为1就表示这是一个连接请求或连接接受报文.
11.	终止FIN	用来释放一个连接.当FIN=1时,表明此报文段的发送方的数据已发送完毕,并要求释放运输连接.
12.	窗口	占2字节.窗口值是[0, 2^16 -1]之间的整数.窗口指的是发送本报文段的一方的接收窗口(**而不是自己的发送窗口**).窗口值告诉对方:从本报文段首部中的确认号算起,接收方目前允许对方发送的数据量(以字节为单位).之所以要有这个限制,是因为接收方的数据缓存空间是有限的.总之,窗口值作为接收方让发送方设置其发送窗口的依据.<br>
例如,发送了一个报文段,其确认号是701,窗口字段是1000.这就是告诉对方:从701号算起,我(即发送此报文段的一方)的接收缓存空间还可接收1000个字节数据(字节序号是701~1700),你在给我发送数据时,必须考虑到这一个点.<br>
总之,应当记住:	窗口字段明确指出了现在允许对方发送的数据量.窗口值经常在动态变化着.
13.	检验和	占2字节.检验和字段检验的范围包括首部和数据这两部分.
14.	紧急指针	占2字节.紧急指针仅在URG=1时才有意义,它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据).因此,紧急指针指出了紧急数据的末尾在报文段中的位置.当所有紧急数据都处理完时,TCP就告诉应用程序恢复到正常操作.指的注意的是,即使窗口为零时也可发送紧急数据.
15.	选项	长度可变,最长可达40字节.当没有使用"选项"时,TCP的首部长度是20字节.


##	TCP可靠传输的实现

TCP的滑动窗口是以字节为单位的.现假定A收到了B发来的确认报文段,其中窗口是20字节,而确认号是31(这表明B期望收到的下一个序号是31,而序号30为止的数据已经收到了).根据这两个数据,A就构造出自己的发送窗口.
![MsaLm8.png](https://s2.ax1x.com/2019/11/17/MsaLm8.png)
发送窗口表示:在没有收到B的确认的情况下,A可以连续把窗口内的数据都发送出去.凡是已经发送过的数据,在未收到确认之前都必须暂时保留,以便在超时重传时使用.

再看一下B的接收窗口.
![MswgaD.png](https://s2.ax1x.com/2019/11/17/MswgaD.png)
B的接收窗口大小是20.在接收窗口外,到30号为止的数据时已经发送过确认,并且已经交付主机了.因此B可以不再保留这些数据.接收窗口内的序号(31~50)是允许接收的.上图中,B收到了序号为32和33的数据,这些数据没有按序到达,因为序号31的数据没有收到(也许丢失了,也许滞留在网络中).**<font color="red">请注意,B只能对按序收到的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然是31(即期望收到的序号),而不能是32或33</font>**.<br><br>
现在假定B收到了序号为31的数据,并把序号31~33的数据交付主机,然后B删除这些数据.接着把接收窗口向前移动3个序号,同时给A发送确认,其中窗口值扔为20,但确认号是34.这表明B已经收到了序号33为止的数据.我们注意到,B还收到了序号为37,38,40的数据,但这些都没有按序到达,只能先暂存在接收窗口中.A收到B的确认后,就可以把发送窗口向前华东3个序号.如下图:
![Ms0xte.png](https://s2.ax1x.com/2019/11/17/Ms0xte.png)