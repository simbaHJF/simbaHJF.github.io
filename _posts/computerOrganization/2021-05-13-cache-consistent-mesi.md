---
layout:     post
title:      "多核CPU缓存一致性与MESI协议"
date:       2021-05-13 16:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 计算机组成原理

---









## 导航
[一. 多核CPU带来的缓存一致性问题](#jump1)
<br>
[二. 解决缓存一致性问题的思想机制](#jump2)
<br>
[三. 具体实现:总线嗅探机制和MESI协议](#jump3)
<br>









<br><br>
## <span id="jump1">一. 多核CPU带来的缓存一致性问题</span>

多核 CPU 里的每一个 CPU 核,都有独立的属于自己的 L1 Cache 和 L2 Cache.多个 CPU 之间,只是共用 L3 Cache 和主内存.CPU Cache 解决的是内存访问速度和 CPU 的速度差距太大的问题,多核 CPU 提供的是,在主频难以提升的时候,通过增加 CPU 核心来提升 CPU 的吞吐率的办法.把多核和 CPU Cache 两者一结合,就带来了一个新的挑战.因为 CPU 的每个核各有各的缓存,互相之间的操作又是各自独立的,就会带来缓存一致性



<br><br>
## <span id="jump2">二. 解决缓存一致性问题的思想机制</span>

为解决缓存一致性问题,需做到如下机制:
1. 写传播 : 在一个CPU核心里,Cache数据更新,必须能够传播到其他的对应节点的Cache Line里.
2. 事务串行化 : 在一个CPU核心里面的读取和写入,在其他的节点看起来,顺序应是一致的.
	> 这里解释一下,如4核CPU,对于同一份内存数据(原值假设为8000),CPU核心1将其更新为5000,差不多同一时间CPU核心2将其更新为6000.这两个修改都会传播到核心3和4,然而核心3先收到了核心1的更改后收到核心2的更改,而核心4反过来,先收到核心2的更改再收到核心1的.这就会造成不一致.<br>
	因此我们需要的是,从1到4号核心,都能看到相同顺序的数据变化.在此就需要事务串行化保证机制

在 CPU Cache 里做到事务串行化,需要做到两点,第一点是一个 CPU 核心对于数据的操作,需要同步通信给到其他 CPU 核心.第二点是,如果两个 CPU 核心里有同一个数据的 Cache,那么对于这个 Cache 数据的更新,需要有一个"锁"的概念.只有拿到了对应 Cache Block 的"锁"之后,才能进行对应的数据更新



<br><br>
## <span id="jump3">三. 具体实现:总线嗅探机制和MESI协议</span>

<br>
**<font size="4">总线嗅探(Bus Snooping)</font>** <br>

本质上就是把所有的读写请求都通过总线(Bus)广播给所有的 CPU 核心,然后让各个核心去"嗅探"这些请求,再根据本地的情况进行响应.<br>


<br>
**<font size="4">MESI协议</font>** <br>

基于总线嗅探机制,其实还可以分成很多种不同的缓存一致性协议,其中最常用的,就是 MESI 协议.<br>

MESI 协议,是一种叫作<font color="red">写失效</font>(Write Invalidate)的协议.在写失效协议里,只有一个 CPU 核心负责写入数据,其他的核心,只是同步读取到这个写入.在这个 CPU 核心写入 Cache 之后,它会去广播一个"失效"请求告诉所有其他的 CPU 核心.其他的 CPU 核心,只是去判断自己是否也有一个"失效"版本的 Cache Block,然后把这个也标记成失效的就好了.<br>

MESI协议由来于对Cache Line的四个不同的标记,分别是:
* M(Modified) : 缓存行是脏的(dirty),与主存的值不同.如果别的CPU内核要读主存这块数据,该缓存行必须回写到主存,状态变为共享(S).
* E(Exclusive) : 缓存行只在当前缓存中,但是干净的(clean)--缓存数据同于主存数据.当别的缓存读取它时,状态变为共享;当写数据时,变为已修改状态(M)
* S(Shared) : 缓存行也存在于其它缓存中且是干净的.缓存行可以在任意时刻抛弃
* I(Invalid) : 缓存行是无效的

写操作仅在缓存行是已修改或独占状态时可自由执行.如果在共享状态,其他缓存都要先把该缓存行置为无效,这种广播操作称作Request For Ownership (RFO).<br>

<font color="red">所以这里,M和I的区别是,当缓存行为S状态时,发生对其值的修改,那么发起执行修改操作的CPU核心首先会通过总线广播使其他核心将该缓存置失效状态,然后该核心中对应缓存行改为E状态,此时可修改,修改后变为M状态,其他通过总线嗅探到Cache Line被修改的CPU核心会将自己的对应缓存行状态设置为I</font> <br>


> 如果说一个核心更新了数据,广播失效操作和地址,其他核心的缓存被更新为失效,那更新数据的那个核心什么时候把数据再次写入内存呢,按照之前所述'写回'机制,在下次更新数据的时候才会写入,那如果在这个之间,别的核心需要用到这部分数据,看到失效,还是从内存读,这不是还是读不到最新的数据么? <br><br>
  假设CPU A的Cache Line被标记为M，CPU B的Cache Line被标记为I.此时CPU B需要读取这部分数据,由于Cache Line被标记为I,因此不满足读请求,便通过总线进行广播.这个时候CPU A收到来自总线读(remote read)的请求,其Cache Line状态由M->S,并将数据更新进内存.由于内存中数据已更新为最新,因此CPU B可以将内存中的数据加载到Cache Line中,以满足本地的读请求(local read),并将Cache Line状态由I->S.<br>
  当然,这块的实现中,不同的CPU实现会有不同的方式,也其他的实现方式比如:核心B想要读数据,通过总线,从核心A来读取.不同的CPU架构有不同实现而已.

[![gs6VxS.png](https://z3.ax1x.com/2021/05/14/gs6VxS.png)](https://imgtu.com/i/gs6VxS)

