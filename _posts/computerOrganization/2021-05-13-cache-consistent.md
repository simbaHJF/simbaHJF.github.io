---
layout:     post
title:      "多核CPU缓存一致性与MESI协议"
date:       2021-05-13 16:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 计算机组成原理

---









## 导航
[一. 多核CPU带来的缓存一致性问题](#jump1)
<br>
[二. 解决缓存一致性问题的思想机制](#jump2)
<br>
[三. 具体实现:总线嗅探机制和MESI协议](#jump3)
<br>









<br><br>
## <span id="jump1">一. 多核CPU带来的缓存一致性问题</span>

多核 CPU 里的每一个 CPU 核,都有独立的属于自己的 L1 Cache 和 L2 Cache.多个 CPU 之间,只是共用 L3 Cache 和主内存.CPU Cache 解决的是内存访问速度和 CPU 的速度差距太大的问题,多核 CPU 提供的是,在主频难以提升的时候,通过增加 CPU 核心来提升 CPU 的吞吐率的办法.把多核和 CPU Cache 两者一结合,就带来了一个新的挑战.因为 CPU 的每个核各有各的缓存,互相之间的操作又是各自独立的,就会带来缓存一致性



<br><br>
## <span id="jump2">二. 解决缓存一致性问题的思想机制</span>

为解决缓存一致性问题,需做到如下机制:
1. 写传播 : 在一个CPU核心里,Cache数据更新,必须能够传播到其他的对应节点的Cache Line里.
2. 事务串行化 : 在一个CPU核心里面的读取和写入,在其他的节点看起来,顺序应是一致的.
	> 这里解释一下,如4核CPU,对于同一份内存数据(原值假设为8000),CPU核心1将其更新为5000,差不多同一时间CPU核心2将其更新为6000.这两个修改都会传播到核心3和4,然而核心3先收到了核心1的更改后收到核心2的更改,而核心4反过来,先收到核心2的更改再收到核心1的.这就会造成不一致.<br>
	因此我们需要的是,从1到4号核心,都能看到相同顺序的数据变化.在此就需要事务串行化保证机制

在 CPU Cache 里做到事务串行化,需要做到两点,第一点是一个 CPU 核心对于数据的操作,需要同步通信给到其他 CPU 核心.第二点是,如果两个 CPU 核心里有同一个数据的 Cache,那么对于这个 Cache 数据的更新,需要有一个"锁"的概念.只有拿到了对应 Cache Block 的"锁"之后,才能进行对应的数据更新



<br><br>
## <span id="jump3">三. 具体实现:总线嗅探机制和MESI协议</span>

<br>
**<font size="4">总线嗅探(Bus Snooping)</font>** <br>

本质上就是把所有的读写请求都通过总线(Bus)广播给所有的 CPU 核心,然后让各个核心去"嗅探"这些请求,再根据本地的情况进行响应.<br>


<br>
**<font size="4">MESI协议</font>** <br>

基于总线嗅探机制,其实还可以分成很多种不同的缓存一致性协议,其中最常用的,就是 MESI 协议.<br>

MESI 协议,是一种叫作写失效(Write Invalidate)的协议.在写失效协议里,只有一个 CPU 核心负责写入数据,其他的核心,只是同步读取到这个写入.在这个 CPU 核心写入 Cache 之后,它会去广播一个"失效"请求告诉所有其他的 CPU 核心.其他的 CPU 核心,只是去判断自己是否也有一个"失效"版本的 Cache Block,然后把这个也标记成失效的就好了.<br>

