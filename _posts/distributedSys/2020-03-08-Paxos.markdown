---
layout:     post
title:      "分布式系统--Paxos"
date:       2020-03-08 20:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 分布式

---

> Reference: <br/>
	从Paxos到Zookeeper分布式一致性原理与实践

Paxos算法需要解决的问题是如何在一个可能发生宕机或网络异常的分布式系统中,快速且正确地在集群内部对某个数据的值达成一致,并且保证不论发生以上任何异常,都不会破坏整个系统的一致性.


#	一.	问题描述

假如有一组可以提出提案的进程集合,那么对于一个一致性算法来说需要保证以下几点:

*	在这些被提出的提案中,只有一个会被选定
*	如果没有提案被提出,那么就不会有被选定的提案
*	当一个提案被选定后,进程应该可以获取被选定的提案信息
<br>

对一致性来说,安全性需求如下:

*	只有被提出的提案才能被选定
*	只能有一个值被选定
*	如果某个进程认为某个提案被选定了,那么这个提案必须是真的被选定的那个
<br>

在对Paxos算法的讲解过程中,我们不去精确地定义其活性(Liveness)需求,从整体上来说,Paxos算法的目标就是要保证最终有一个提案会被选定,当提案被选定后,进程最终也能获取到被选定的提案.

在Paxos一致性算法中,有三种参与角色,我们用Proposer,Acceptor和Learner来表示.在具体的实现中,一个进程可能充当不止一种角色,在这里我们并不关心进程如何映射到各种角色.假设不同参与者之间可以通过收发消息来进行通信,那么:

*	每个参与者以任意的速度执行,可能会因为出错而停止,也可能会重启.同时,即使一个提案被选定后,所有的参与者也都有可能失败或重启,因此除非那些失败或重启的参与者可以记录某些信息,否则将无法确定最终的值.
*	消息在传输过程中可能会出现不可预知的延迟,也可能会重复或丢失,但是消息不会被损坏,即消息内容不会被篡改.


#	二.	提案的选定

要选定一个唯一提案的最简单方式莫过于只允许一个Acceptor存在,这样的话,Proposer只能发送提案给该Acceptor,Acceptor会选择它接收到的第一个提案作为被选定的提案.这种解决方式尽管实现起来非常简单,但是却很难让人满意,因为一旦这个Acceptor出现问题,那么整个系统就无法正常工作了.

因此,应该寻找一种更好的解决方式,例如可以使用多个Acceptor来避免Acceptor的单点问题.现在我们就来看看,在存在多个Acceptor的情况下,如何进行提案的选取:

Proposer向一个Acceptor集合发送提案,同样,集合中的每个Acceptor都可能会批准该提案,当有足够多的Acceptor批准这个提案的时候,我们就可以认为该提案被选定了.那么什么是足够多呢?我们假定足够多的Acceptor是整个Acceptor集合的一个子集,并且让这个集合大的可以包含整个Acceptor集合中的大多数成员,因为任意两个包含大多数Acceptor的子集至少有一个公共成员,另外我们再规定,每一个Acceptor最多只能批准一个提案,那么就能保证只有一个提案被选定了.

<font color="red">这里我提一句,上面的推理和方案,就是为什么现在的分布式服务基本上都要求有奇数个节点的原因:<br>
多个节点,保证了高可用,避免单点问题<br>
奇数个节点,保证了只要数据被:节点数/2以上个节点接收写入了,就满足上述的被大多数Acceptor批准的条件.也就是5节点集群有3个节点被写入了;7节点集群有4个被写入了
</font>


#	三.	推导过程

**<font color="red">原书中写的推导过程,对我而言,逻辑顺序简直bullshit.这里按我理解后的逻辑,重新梳理下.</font>**


算法最终目的:	分布式系统中,选定唯一提案


解决方案:  提案被多数Acceptor批准----称之为选定


在提案被多数Acceptor批准的解决方案之下,为了可以保证一致性,也即选定唯一提案,还需满足需求:
1.	即使在只有一个提案被提出的情况下,仍然可以选出一个提案----选定
2.	多个提案被多个Proposer同时提出的情况下,能够选定一个提案.


为满足需求1,需要满足条件P1:  一个Acceptor必须批准它收到的第一个提案  
但是由此,引出一个问题:多个提案被多个Acceptor平均批准了,没有提案能够达到多数Acceptor批准的要求.  
因此,这里暗含了一个需要满足的前提:一个Acceptor必须能够批准不止一个提案.  
由此,采用如下方案来区分提案:使用全局编号来唯一确定每个被提出的提案.由此,提案变成如下形式----[编号,Value]


此时,选定可以是这种情况----多个提案被选定,他们的编号不一样,但是Value一样.这是一个关于Value的约定,结合提案编号,可将该约定定义如下:  
P2:如果编号为M0,Value值为V0的提案(即[M0,V0])被选定了,那么所有比编号M0更高的,且被选定的提案,其Value值也必须是V0.

这时,解决方案 + 约定P1 + 约定P2.就能保证一致性了.为什么这么说呢?因为解决方案的描述是笼统的,只针对提案内容的(没有编号和Value的概念),而由前面的分析,具体实施的时候,提案是[编号,Value]的形式,为符合此时选定条件(多个提案被选定,他们的编号不一样,但是Value一样),则需要结合约定1+约定2来实施.

