---
layout:     post
title:      "分布式系统--Paxos"
date:       2020-03-08 20:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 分布式

---

> Reference: <br/>
	从Paxos到Zookeeper分布式一致性原理与实践<br>
	Jeffbond的简书

Paxos算法需要解决的问题是如何在一个可能发生宕机或网络异常的分布式系统中,快速且正确地在集群内部对某个数据的值达成一致,并且保证不论发生以上任何异常,都不会破坏整个系统的一致性.

<font color="red">这里某个数据的值并不只是狭义上的某个数,它可以是一条日志,也可以是一条命令,根据应用场景不同,某个数据的值有不同的含义.</font>



#	一.	问题描述

假如有一组可以提出提案的进程集合,那么对于一个一致性算法来说需要保证以下几点:

*	在这些被提出的提案中,只有一个会被选定
*	如果没有提案被提出,那么就不会有被选定的提案
*	当一个提案被选定后,进程应该可以获取被选定的提案信息
<br>

对一致性来说,安全性需求如下:

*	只有被提出的提案才能被选定
*	只能有一个值被选定
*	如果某个进程认为某个提案被选定了,那么这个提案必须是真的被选定的那个
<br>

在对Paxos算法的讲解过程中,我们不去精确地定义其活性(Liveness)需求,从整体上来说,Paxos算法的目标就是要保证最终有一个提案会被选定,当提案被选定后,进程最终也能获取到被选定的提案.

在Paxos一致性算法中,有三种参与角色,我们用Proposer,Acceptor和Learner来表示.在具体的实现中,一个进程可能充当不止一种角色,在这里我们并不关心进程如何映射到各种角色.假设不同参与者之间可以通过收发消息来进行通信,那么:

*	每个参与者以任意的速度执行,可能会因为出错而停止,也可能会重启.同时,即使一个提案被选定后,所有的参与者也都有可能失败或重启,因此除非那些失败或重启的参与者可以记录某些信息,否则将无法确定最终的值.
*	消息在传输过程中可能会出现不可预知的延迟,也可能会重复或丢失,但是消息不会被损坏,即消息内容不会被篡改.

Proposer:	提出提案  
Acceptor:	接收提案  
Learner:	复制Acceptor的状态(即Acceptor告诉Learner哪个Value被选定了)

#	三.	提案的选定

要选定一个唯一提案的最简单方式莫过于只允许一个Acceptor存在,这样的话,Proposer只能发送提案给该Acceptor,Acceptor会选择它接收到的第一个提案作为被选定的提案.这种解决方式尽管实现起来非常简单,但是却很难让人满意,因为一旦这个Acceptor出现问题,那么整个系统就无法正常工作了.

因此,应该寻找一种更好的解决方式,例如可以使用多个Acceptor来避免Acceptor的单点问题.现在我们就来看看,在存在多个Acceptor的情况下,如何进行提案的选取:

Proposer向一个Acceptor集合发送提案,同样,集合中的每个Acceptor都可能会批准该提案,当有足够多的Acceptor批准这个提案的时候,我们就可以认为该提案被选定了.那么什么是足够多呢?我们假定足够多的Acceptor是整个Acceptor集合的一个子集,并且让这个集合大的可以包含整个Acceptor集合中的大多数成员,因为任意两个包含大多数Acceptor的子集至少有一个公共成员,另外我们再规定,每一个Acceptor最多只能批准一个提案,那么就能保证只有一个提案被选定了.

<font color="red">这里我提一句,上面的推理和方案,就是为什么现在的分布式服务基本上都要求有奇数个节点的原因:<br>
奇数个节点,保证了只要数据被:节点数/2以上个节点接收写入了,就满足上述的被大多数Acceptor批准的条件.也就是5节点集群有3个节点被写入了;7节点集群有4个被写入了
</font>



#	四.	推导过程

首先,这里有一个对于提案被选定的最近本规定:一个提案被选定需要被半数以上的Acceptor批准.

这个规定,是下面所有推导的基础.

下面来推导一下,如何保证在多个Proposer和多个Acceptor的情况下选定一个提案

![GBvVuq.png](https://s1.ax1x.com/2020/04/05/GBvVuq.png)

我们希望即使只有一个Proposer提出了一个提案,该提案也能最终被选定.<br><br>
于是得到,需要满足如下的约束条件:  

> `P1:一个Acceptor必须接受它收到的第一个提案`

此时,又会引出另外一个问题:如果每个Proposer分别提出不同的提案,发给不同的Acceptor,根据P1,Acceptor分别接受自己收到的第一个提案,此时没有提案满足被选定的条件.
[![GBxX0P.png](https://s1.ax1x.com/2020/04/05/GBxX0P.png)](https://imgchr.com/i/GBxX0P)

因此,在P1的基础上,若要满足提案被选定的定义:需要由半数以上的Acceptor批准.那么此时暗含了一个条件:一个Acceptor必须能够批准不止一个提案.

这里,我们使用一个全局的编号来唯一标识一个提案,当一个具有某Value值的提案被半数以上的Acceptor批准后,我们就认为该Value被选定了,也认为该提案被选定了.

<font color="red">注意,在此之前我们讲的提案,和Value是同一个概念;但是为了满足上文提到的暗含条件,我们采用给提案加编号的解决方案,所以在此之后,提案已经和Value不是同一个概念了,提案变成了一个由编号和Value组成的组合体,我们以[编号,Value]来表示一个提案.</font>


根据上面讲到的,虽然允许多个提案被选定,但同时必须要保证所有被选定提案都具有相同的Value值----这是一个关于提案Value的约定,结合提案的编号,该约定可以定义如下:

> `P2:如果编号为M0,Value值为V0的提案(即[M0,V0])被选定了,那么所有比编号M0更高的,且被选定的提案,其Value值必须也是V0`.

以为提案的编号是全序的,条件P2就保证了只有一个Value值被选定这一关键安全性属性.  
同时,一个提案要被选定,其首先必须被至少一个Acceptor批准,因此我们可以通过满足如下条件来满足P2:

> `P2a:如果编号为M0,value值为V0的提案(即[M0,V0])被选定了,那么所有比编号M0更高的,且被Acceptor批准的提案,其Value值必须也是V0`

至此,我们仍然需要P1来保证提案会被选定,但是因为通信是异步的,一个提案可能会在某个Acceptor还未收到任何提案时就被选定了.

举例来讲:假设共有5个Acceptor,Proposer2提出了[M1,V1]的提案.Acceptor2~Acceptor5均接受了该提案,于是对于Acceptor2~Acceptor5和Proposer2来讲,他们都认为V1被选定了,此时Acceptor1刚刚从宕机状态恢复过来或者刚刚新加入集群或者就是单纯的没收到过提案(也就是说,Acceptor1之前没有收到过任何提案),此时Proposer1向Acceptor1发送了[M2,V2]的提案(V2!=V1且M2>M1),对于Acceptor1来讲,这是它收到的第一个提案.如下图所示:

![GDFlGV.png](https://s1.ax1x.com/2020/04/05/GDFlGV.png)

根据P1,Acceptor1必须批准该提案,但是这就与P2a矛盾,因此如果需要同时满足P1和P2a,需要对P2a进行如下强化:

> `P2b:如果一个提案[M0,V0]被选定后,那么之后任何Proposer产生的编号更高的提案,其Value值都必须为V0`

因为一个提案必须被Proposer提出后才能被Acceptor批准,因此P2b包含了P2a,进而包含了P2.

那么,如何确保在某个Value为V0的提案被选定后,之后任何Proposer提出的编号更高的提案的Value都是V0呢?只需满足进一步加强的P2c即可:

> `P2c:对于任意的Mn和Vn,如果提案[Mn,Vn]被提出,那么肯定存在一个半数以上的Acceptor组成的集合S,满足以下两个条件中的任意一个:`
  *	`S中不存在任何批准过编号小于Mn的提案的Acceptor`
  *	`选取S中所有Acceptor批准的编号小于Mn的提案,其中编号最大的那个提案其Value值是Vn`

上面条件,满足一个就可以.其中条件一,是针对Acceptor集群处于刚初始化完的全新状态,还未批准过任何提案;条件二,是针对Acceptor集群已经在运行当中,且已经批准过一些提案的情况下.

至此,只需要通过保持P2c,我们就能满足P2b了.

从上面的内容中,我们可以看到,从P1到P2c的过程其实是对一系列条件的逐步加强,实际上P2c规定了每个Proposer如何产生一个提案.


#	五.Proposer生成提案与Acceptor批准提案

###	五.1 Proposer生成提案

现在我们来看看,在P2c的基础上如何进行提案的生成.对于一个Proposer来说,获取那些已经被通过的提案远比预测未来可能会被通过的提案来的简单.因此,这里有一个重要的思想:Proposer生成提案之前,应该先去"学习"已经被选定或者可能被选定的value,然后以该value作为自己提出的提案的value;如果没有value被选定,Proposer才可以自己决定value的值.换句话说,Proposer在产生一个编号为Mn的提案时,必须要知道当前某一个将要或已经被半数以上Acceptor批准的编号小于Mn但为最大编号的提案.并且,Proposer会要求所有的Acceptor都不要再批准任何编号小于Mn的提案----这就引出了如下的提案生成算法.

1.	Proposer选择一个新的提案编号Mn,然后向某个Acceptor集合的成员发送请求,要求该集合中的Acceptor做出如下回应.
	*	向Proposer承诺,保证不再批准任何编号小于Mn的提案.
	*	如果Acceptor已经批准过任何提案,那么其就向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值.

	我们将该请求称为编号为Mn的提案的Prepare请求.
2.	如果Proposer收到了来自半数以上的Acceptor的响应结果,那么它就可以产生编号为Mn,Value值为Vn的提案,这里的Vn是所有响应中编号最大的提案的Value值.当然还存在另一种情况,就是半数以上的Acceptor都没有批准过任何提案,即响应中不包含任何的提案,那么此时Vn值就可以由Proposer任意选择.

在确定提案之后,Proposer就会将该提案在此发送给某个Acceptor集合,并期望获得它们的批准,我们称此请求为Accept请求.需要注意的一点是,此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合----这点相信读者也能够明白,任意两个半数以上的Acceptor集合,必定包含至少一个公共Acceptor.

###	五.2 Acceptor批准提案

在上文中,我们已经讲解了Paxos算法中Proposer的处理逻辑,下面我们来看看Acceptor是如何批准提案的.

根据上面的内容,一个Acceptor可能会收到来自Proposer的两种请求,分别是Prepare请求和Accept请求,对这两类请求作出响应的条件分别如下.
*	Prepare请求: Acceptor可以在任何时候响应一个Prepare请求
*	Accept请求: 在不违背Accept现有承诺的前提下,可以任意响应Accept请求

因此,对Acceptor逻辑处理的约束条件,大体可以定义如下:
> `P1a: 一个Acceptor只要尚未响应过任何编号大于Mn的Prepare请求,那么它就可以接受这个编号为Mn的提案`

###	五.3 算法优化

在上面的内容中,我们分别从Proposer和Acceptor对提案的生成和批准两方面来讲解了Paxos算法在提案选定过程中的算法细节,同时也在提案的编号全局唯一的前提下,获得了一个满足安全性需求的提案选定算法,接下来我们在对这个初步算法做一个小优化.尽可能地忽略Prepare请求:

> 假设一个Acceptor收到了一个编号为Mn的Prepare请求,但此时该Acceptor已经对编号大于Mn的Prepare请求做出了响应,因此它肯定不会再批准任何新的编号为Mn的提案,那么很显然,Acceptor就没有必要对这个Prepare请求作出响应,于是Acceptor可以选择忽略这样的Prepare请求.同时,Acceptor也可以忽略掉那些它已经批准过提案的Prepare请求.

通过这个优化,每个Acceptor只需要记住它已经批准的提案的最大编号以及它已经作出Prepare请求响应的提案的最大编号,以便在故障或节点重启的情况下,也能保证P2c的不变性.而对于Proposer来说,只要它可以保证不会产生具有相同编号的提案,那么就可以丢弃任意的提案以及它所有的运行时状态信息.



#	六. 算法陈述总结

综合前面讲解的内容,我们来对Paxos算法的提案选定过程进行一个陈述.结合Proposer和Acceptor对提案的处理逻辑,就可以得到如下类似于两阶段提交的算法执行过程.

**阶段一**

1.	Proposer选择一个提案编号Mn,然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求.
2.	如果一个Acceptor收到一个编号为Mn的Prepare请求,且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号,那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer,同时该Acceptor会承诺不会再批准任何编号小于Mn的提案


**阶段二**

1.	如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应,那么它就会发送一个针对[Mn,Vn]提案的Accept请求给Acceptor.注意,Vn的值就是收到的响应中编号最大的提案的值,如果响应中不包含任何提案,那么它就是任意值.
2.	如果Acceptor收到这个针对[Mn,Vn]提案的Accept请求,只要该Acceptor尚未对编号大于Mn的Prepare请求做出响应,它就可以通过(批准)这个提案.


#	七. 通过选取主Proposer保证算法的活性

根据前面的内容讲解,我们已经基本上了解了Paxos算法的核心逻辑,下面我们再来看看Paxos算法在实际作过程中的一些细节.假设存在这样一种极端情况,有两个Proposer依次提出了一系列编号递增的议案,但是最终都无法被选定,具体流程如下:

> Proposer P1提出了一个编号为M1的提案,并完成了上述阶段一的流程.但与此同时,另外一个Proposer P2提出了一个编号为M2(M2>M1)的提案,同样也完成了阶段一的流程,于是Acceptor已经承诺不再批准编号小于M2的提案了.因此,当P1进入阶段二的时候,其发出的Accept请求将被Acceptor忽略,于是P1再次进入阶段一并提出了一个编号为M3(M3>M2)的提案,而这又导致P2在第二阶段的Accept请求被忽略,以此类推,提案的选定过程将陷入死循环.

为了保证Paxos算法流程的可持续性,以避免陷入上述提到的"死循环",就必须选择一个主Proposer,并规定只有主Proposer才能提出议案.这样一来,只要主Proposer和过半的Acceptor能够正常进行网络通信,那么但凡主Proposer提出一个编号更高的提案,该提案终将会被批准.因此,如果系统中有足够多的组件(包括Proposer,Acceptor和其他网络通信组件)能够正常工作,那么通过选择一个主Proposer,整套Paxos算法流程就能够保持活性.