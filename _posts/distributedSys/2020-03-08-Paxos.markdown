---
layout:     post
title:      "分布式系统--Paxos"
date:       2020-03-08 20:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - 分布式

---

> Reference: <br/>
	从Paxos到Zookeeper分布式一致性原理与实践

Paxos算法需要解决的问题是如何在一个可能发生宕机或网络异常的分布式系统中,快速且正确地在集群内部对某个数据的值达成一致,并且保证不论发生以上任何异常,都不会破坏整个系统的一致性.


#	一.	问题描述

假如有一组可以提出提案的进程集合,那么对于一个一致性算法来说需要保证以下几点:

*	在这些被提出的提案中,只有一个会被选定
*	如果没有提案被提出,那么就不会有被选定的提案
*	当一个提案被选定后,进程应该可以获取被选定的提案信息
<br>

对一致性来说,安全性需求如下:

*	只有被提出的提案才能被选定
*	只能有一个值被选定
*	如果某个进程认为某个提案被选定了,那么这个提案必须是真的被选定的那个
<br>

在对Paxos算法的讲解过程中,我们不去精确地定义其活性(Liveness)需求,从整体上来说,Paxos算法的目标就是要保证最终有一个提案会被选定,当提案被选定后,进程最终也能获取到被选定的提案.

在Paxos一致性算法中,有三种参与角色,我们用Proposer,Acceptor和Learner来表示.在具体的实现中,一个进程可能充当不止一种角色,在这里我们并不关心进程如何映射到各种角色.假设不同参与者之间可以通过收发消息来进行通信,那么:

*	每个参与者以任意的速度执行,可能会因为出错而停止,也可能会重启.同时,即使一个提案被选定后,所有的参与者也都有可能失败或重启,因此除非那些失败或重启的参与者可以记录某些信息,否则将无法确定最终的值.
*	消息在传输过程中可能会出现不可预知的延迟,也可能会重复或丢失,但是消息不会被损坏,即消息内容不会被篡改.


#	二.	提案的选定

要选定一个唯一提案的最简单方式莫过于只允许一个Acceptor存在,这样的话,Proposer只能发送提案给该Acceptor,Acceptor会选择它接收到的第一个提案作为被选定的提案.这种解决方式尽管实现起来非常简单,但是却很难让人满意,因为一旦这个Acceptor出现问题,那么整个系统就无法正常工作了.

因此,应该寻找一种更好的解决方式,例如可以使用多个Acceptor来避免Acceptor的单点问题.现在我们就来看看,在存在多个Acceptor的情况下,如何进行提案的选取:

Proposer向一个Acceptor集合发送提案,同样,集合中的每个Acceptor都可能会批准该提案,当有足够多的Acceptor批准这个提案的时候,我们就可以认为该提案被选定了.那么什么是足够多呢?我们假定足够多的Acceptor是整个Acceptor集合的一个子集,并且让这个集合大的可以包含整个Acceptor集合中的大多数成员,因为任意两个包含大多数Acceptor的子集至少有一个公共成员,另外我们再规定,每一个Acceptor最多只能批准一个提案,那么就能保证只有一个提案被选定了.

<font color="red">这里我提一句,上面的推理和方案,就是为什么现在的分布式服务基本上都要求有奇数个节点的原因:<br>
多个节点,保证了高可用,避免单点问题<br>
奇数个节点,保证了只要数据被:节点数/2以上个节点接收写入了,就满足上述的被大多数Acceptor批准的条件.也就是5节点集群有3个节点被写入了;7节点集群有4个被写入了
</font>

