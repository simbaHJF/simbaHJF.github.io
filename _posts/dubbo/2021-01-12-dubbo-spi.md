---
layout:     post
title:      "Dubbo SPI"
date:       2021-01-12 16:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - dubbo

---


## 导航
一. [Dubbo SPI 扩展简述](#jump1)
<br>
二. [@SPI 注解](#jump2)
<br>
三. [ExtensionLoader 对 @SPI 注解的处理](#jump3)
<br>
四. [URL在Dubbo中的应用场景示例](#jump4)




## <span id="jump1">一. Dubbo SPI 扩展简述</span>

* **扩展点:** 通过 SPI 机制查找并加载实现的接口(又称"扩展接口").Java SPI 一文中介绍的 com.mysql.cj.jdbc.Driver 接口,就是扩展点.

* **扩展点实现:** 实现了扩展接口的实现类.


**Java SPI 的不足:**<br>

JDK SPI 在查找扩展实现类的过程中,需要遍历 SPI 配置文件中定义的所有实现类,该过程中会将这些实现类全部实例化.如果 SPI 配置文件中定义了多个实现类,而我们只需要使用其中一个实现类时,就会生成不必要的对象.例如,org.apache.dubbo.rpc.Protocol 接口有 InjvmProtocol、DubboProtocol、RmiProtocol、HttpProtocol、HessianProtocol、ThriftProtocol 等多个实现,如果使用 JDK SPI,就会加载全部实现类,导致资源的浪费.<br>



**Dubbo SPI 不仅解决了上述资源浪费的问题,还对 SPI 配置文件扩展和修改:**<br>

首先,Dubbo 按照 SPI 配置文件的用途,将其分成了三类目录:
* META-INF/services/ 目录: 该目录下的 SPI 配置文件用来兼容 JDK SPI
* META-INF/dubbo/ 目录: 该目录用于存放用户自定义 SPI 配置文件
* META-INF/dubbo/internal/ 目录: 该目录用于存放 Dubbo 内部使用的 SPI 配置文件

这三类目录优先级从下到上依次升高<br>

然后,Dubbo 将 SPI 配置文件改成了 KV 格式,例如:
```
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
```

其中 key 被称为扩展名(也就是 ExtensionName),当我们在为一个接口查找具体实现类时,可以指定扩展名来选择相应的扩展实现.例如,这里指定扩展名为 dubbo,Dubbo SPI 就知道我们要使用:org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 这个扩展实现类,只实例化这一个扩展实现即可,无须实例化 SPI 配置文件中的其他扩展实现类.<br>

使用 KV 格式的 SPI 配置文件的另一个好处是:让我们更容易定位到问题.假设我们使用的一个扩展实现类所在的 jar 包没有引入到项目中,那么 Dubbo SPI 在抛出异常的时候,会携带该扩展名信息,而不是简单地提示扩展实现类无法加载.这些更加准确的异常信息降低了排查问题的难度,提高了排查问题的效率.



## <span id="jump2">二. @SPI 注解</span>

Dubbo 中某个接口被 @SPI注解修饰时,就表示该接口是扩展接口,如 org.apache.dubbo.rpc.Protocol 接口就是一个扩展接口.

```
@SPI("dubbo")
public interface Protocol {


    int getDefaultPort();

 
    @Adaptive
    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;


    @Adaptive
    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;


    void destroy();


    default List<ProtocolServer> getServers() {
        return Collections.emptyList();
    }

}
```

@SPI 注解的 value 值指定了默认的扩展名称,例如,在通过 Dubbo SPI 加载 Protocol 接口实现时,如果没有明确指定扩展名,则默认会将 @SPI 注解的 value 值作为扩展名,即加载 dubbo 这个扩展名对应的 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 这个扩展实现类,相关的 SPI 配置文件在 dubbo-rpc-dubbo 模块中,如下图所示:
[![sYgiyn.png](https://s3.ax1x.com/2021/01/12/sYgiyn.png)](https://imgchr.com/i/sYgiyn)



## <span id="jump3">三. ExtensionLoader 对 @SPI 注解的处理</span>

ExtensionLoader 位于 dubbo-common 模块中的 extension 包中,功能类似于 JDK SPI 中的 java.util.ServiceLoader.Dubbo SPI 的核心逻辑几乎都封装在 ExtensionLoader 之中(其中就包括 @SPI 注解的处理逻辑),其使用方式如下所示:
```
Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension("dubbo");
```

这里首先来了解一下 ExtensionLoader 中三个核心的静态字段:
* strategies(LoadingStrategy[]类型): LoadingStrategy 接口有三个实现(通过 JDK SPI 方式加载的),如下图所示,分别对应前面介绍的三个 Dubbo SPI 配置文件所在的目录,且都继承了 Prioritized 这个优先级接口,默认优先级是
```
DubboInternalLoadingStrategy > DubboLoadingStrategy > ServicesLoadingStrateg
```
[![sYWapF.png](https://s3.ax1x.com/2021/01/12/sYWapF.png)](https://imgchr.com/i/sYWapF)

* EXTENSION_LOADERS(ConcurrentMap<Class, ExtensionLoader>类型): Dubbo 中一个扩展接口对应一个 ExtensionLoader 实例,该集合缓存了全部 ExtensionLoader 实例,其中的 Key 为扩展接口,Value 为加载其扩展实现的 ExtensionLoader 实例.

* EXTENSION_INSTANCES(ConcurrentMap<Class<?>, Object>类型): 该集合缓存了扩展实现类与其实例对象的映射关系.在前文示例中,Key 为 Class, Value 为 DubboProtocol 对象.