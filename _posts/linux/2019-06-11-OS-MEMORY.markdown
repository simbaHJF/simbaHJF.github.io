---
layout:     post
title:      "操作系统内存管理"
date:       2019-06-11 22:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

>参考资料:<br>
>极客时间<br>
>计算机操作系统(第四版)

### 连续分配存储管理方式
为了能将用户程序装入内存,必须为它分配一定大小的内存空间.连续分配方式是最早出现的一种存储器分配方式.该分配方式为一个用户程序分配一个连续的内存空间,即程序中代码或数据的逻辑地址相邻,体现在内存空间分配时物理地址的相邻.


### 虚拟内存地址
当我们需要在系统中同时运行多道程序时,无法保证某道程序加载在固定的内存段上,也就不能固定程序在内存的加载位置和指令在内存中的绝对地址.
为解决此问题,在内存中找到一段连续的内存空间,将其分配给装载的程序,然后把这段物理内存空间地址和整个程序指令的指定地址做一个映射.物理地址对于进程不可见,操作系统给进程分配一个虚拟地址.所有进程看到的这个地址都是一样的,在程序里面指令的地址都是虚拟地址,当程序要访问虚拟地址的时候,由内核的数据结构进行转换,转换成不同的物理地址.
我们把程序中指令用到的内存地址叫做虚拟内存地址,实际在内存硬件里面的空间地址,叫做物理内存地址.

虚拟地址空间又分为内核空间和用户空间两部分.32位系统的内核空间占用1G,位于高位,剩下的3G是用户空间.而64位系统的内核空间和用户空间都是128T,分别占据整个内存空间的最高处和最低处,剩下的中间部分是未定义的.
![V570Qs.png](https://s2.ax1x.com/2019/06/14/V570Qs.png)

进程在用户态时,只能访问用户空间内存;只有进入内核态后,才可以访问内核空间内存.进程间的内存是隔离的,但各个进程的内核空间,关联的都是相同的物理内存.虚拟内存空间的分布情况如下图:
![V5bOsA.png](https://s2.ax1x.com/2019/06/14/V5bOsA.png)
用户空间内存,从低到高分别是五种不同的内存段.
1. 只读段,包括代码和常量等
2. 数据段,包括全局变量等
3. 堆,包括动态分配的内存,从地地址开始向上增长
4. 文件映射段,包括动态库,共享内存等,从高地址开始向下增长
5. 栈,包括局部变量和函数调用的上下文等
在这五个内存段中,堆和文件映射段的内存是动态分配的.比如说,使用C标准库的malloc()或者mmap(),就可以分别在堆和文件映射段动态分配内存.


### 内存交换(Swapping)
连续分配存储管理方式和虚拟内存地址的结合解决了最初的内存分配问题,但也存在明显的不足,第一个就是内存碎片问题.
例如,我们当前有一台电脑,内存为1GB.我们首先启动一个图形渲染程序,占用512MB内存;接着启动一个Chrome浏览器,占用128MB内存;再启动一个Python程序,占用256MB内存.这时,关掉Chrome,于是空闲内存还有256MB.按理来说,我们有足够的内存空间装在一个200MB的程序.但是,这256MB的内存空间不是连续的,而是被分成了两段128MB的内存.导致那200MB的程序无法被加载进来.
解决上述问题的办法,我们称之为内存交换.
我们可以把Python程序占用的那256MB内存写到硬盘上,然后再从硬盘上读回来到内存里面.不过读回来的时候,不再把它加载到原来的位置,而是紧跟在那已被占用的512MB内存后面.这样就有了256MB的连续内存空间,可以去加载一个新的200MB的程序.如果你自己安装过linux操作系统,你应该遇到过分配一个swap硬盘分区的问题.这块分出来的磁盘空间,其实就是专门给linux操作系统进行内存交换用的.
内存交换不仅用在上述场景中,还可应用于下面这种情况:一方面,在内存中的某些进程由于某件事尚未发生而被阻塞运行,但它却占用了大量的内存空间,甚至阻塞其他进程;另一方面,却又有许多作业,因为内存空间不足,一直驻留在外存上,而不能进入内存运行.显然这是对系统资源的严重浪费,使系统吞吐量下降.这个问题,也可通过内存交换解决,把内存中暂时不能运行的进程或暂时不用的程序和数据换出到外存,以便腾出足够的内存空间,再把已具备运行条件的进程或进程所需要的程序和数据换入内存.


### 离散分配存储管理方式
连续分配存储的方式会形成许多碎片,虽然可通过内存交换的方式进行紧凑,将碎片拼接成可用的大块空间,但需要付出很大的系统开销.如果允许将一个进程直接分散地装入到许多不相邻接的分区中,便可充分利用内存空间,降低内存交换的次数同时降低交换涉及到的内存空间大小.基于这种思想而产生了离散分配方式.

##### 分页存储管理方式
将用户程序的地址空间分为若干个固定大小的区域,称为"页"或"页面";将物理内存空间也分为若干个物理块或页框.页和页框大小相同.这样可将用户程序的任一页放入任一物理块中,实现离散分配.在为进程分配内存时,将进程中的若干个页分别装入到多个可以不相邻接的物理块中.由于进程的最后一页经常装不满一块,而形成了不可利用的碎片,称之为"页内碎片".在linux系统下,页大小通常设置为4KB.

分页地址中的地址结构如下:
![](https://s2.ax1x.com/2019/06/12/VWMfOI.png)
它包含两部分内容:前一部分为页号,后一部分为偏移量,即页内地址.

在分页系统中,允许将进程的各个页离散地存储在内存的任一物理块中,为保证进程仍然能够正确地运行,即能在内存中找到每个页面所对应的物理块,系统又为每个进程建立了一张页面映射表,简称页表.在进程地址空间内的所有页,依次在页表中有一个页表项,其中记录了相应页在内存中对应的物理块号.在配置了页表后,进程执行时,通过查找该表,即可找到每页在内存中的物理块号.因此,页表的作用是实现从页号到物理块号的地址映射.如下图:
![](https://s2.ax1x.com/2019/06/12/VW18TP.png)

当进程访问的虚拟地址在页表中查不到时,系统会产生一个缺页异常,进入内核空间分配物理内存,更新页表,最后在返回用户空间,恢复进程的运行了.

页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大,比如32位系统就需要4GB/4KB个页表项才可以实现整个地址空间的映射.为了解决页表项过多的问题,Linux提空了两种机制,也就是多级页表和大页.
多级页表就是把内存分成区块来管理,将原来的映射关系改成区块索引和区块内的偏移.由于虚拟内存空间通常只使用了很少一部分,那么,多级页表就只保存这些使用中的区块,这样就可以大大减少页表的项数.
linux用的正是四级页表来管理内存页,如下图所示,虚拟地址被分为5个部分,前4个表项用于选择页,而最后一个索引表示页内偏移.
[![V5LJXj.md.png](https://s2.ax1x.com/2019/06/14/V5LJXj.md.png)](https://imgchr.com/i/V5LJXj)

再看大页,顾名思义,就是比普通页更大的内存块,常见的大小有2MB和1GB.大页通常用在使用大量内存的进程上,比如Oracle等.



