---
layout:     post
title:      "Page Cache----页高速缓存"
date:       2019-06-17 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

>参考资料:<br>
深入理解Linux内核(第三版)

##	Page Cache----页高速缓存
Page Cache是Linux使用的主要硬盘缓存.在大多数情况下,当Linux内核从硬盘读入数据或向硬盘写入数据时,会用到Page Cache.当一个用户态进程有一个读请求时,新的页将会被加入到Page Cache中.如果页当前不再Page Cache中,一个新的entry将被添加到缓存中,这个entry由从磁盘读取的数据来填充.当空闲内存足够时,页将无时间限制的长久保持在缓存中,以便被其他进程重用,来避免访问硬盘.<br>

类似的,在写一页数据到块设备之前,内核会验证相应的页是否已经在缓存里;如果没有,一个新的entry将会被添加到缓存中,并且该entry由将要写入硬盘的数据来填充.I/O数据传输并不会立即开始:硬盘更新将会延迟一些时间,因此给进程对将要写入的数据进行进一步修改的机会(换句话说,内核实现了延迟写操作)<br>

实际上,所有的read()和write()的文件操作都依赖Page Cache.唯一的例外是:当一个进程以O_DIRECT标识来打开文件时.在这种情况下,Page Cache被绕过,I/O数据传输利用进程用户态地址空间的buffer来传输数据.一些数据库应用会利用O_DIRECT标识,这样一来他们能够使用自己的硬盘缓存算法.<br>

内核设计者实现了Page Cache,它满足如下两方面需求:
*	快速定位与给定所有者相关数据的特定页.为了最大程度的发挥Page Cache的优势,对它的搜索应该是一个非常快的操作.
*	记录下在读写页中数据时cache中的每个页应该被如何处理.例如,从一个常规文件读取页,从一个块设备读取页,或者从swap区读取一个页一定是以不同的方式来执行的,因此内核必须依据不同的页所有者来选择适当的操作方式.


Page Cache持有的信息单元,是一整页的数据.其中包含的磁盘块在物理上不一定是相邻的,所以不能通过设备号和块号来识别它.取而代之的是,Page Cache中的页是被所有者和所有者数据中的索引(通常是一个索引节点和在相应文件中的偏移量)来表示.


## address_space对象
页高速缓存的核心数据结构是address_space对象,它是一个嵌入在页所有者的索引节点对象中的数据结构.cache中的许多页可能属于同一个所有者,因此它们可能会被连接到同一个address_space对象.该对象还会在所有者的页和对这些页的一系列方法操作集合之间建立链接关系.<br>

每个页描述符包括把页链接到Page Cache的两个字段mapping和index.mapping字段指向拥有页的索引节点的address_space对象,index字段表示在所有者的地址空间中以页大小为单位的偏移量,也就是在所有者的磁盘映像中页数据的位置.在Page Cache中查找页时使用这两个字段.


## 基树
Linux支持大到几个TB的文件.访问大文件时,Page Cache中可能充满太多的文件页,以至于顺序扫描这些页需要消耗大量的时间.为了实现页高速缓存的高效查找,Linux 2.6采用了大量的搜索树,其中每个address_space对象对应一颗搜索树.<br>

address_space对象的page_tree字段是基树的根,它包含指向所有者的页描述符的指针.给定的页索引表示页在所有者磁盘映像中的位置,内核能够通过快速搜索操作来确定所需要的页是否在Page Cache中.当查找所需要的页时,内核把页索引转换为基树的路径,并快速找到也描述符所在的(或应当在的)位置.如果找到,内核可以从基树获得页描述符,而且还可以很快确定所找到的页是否为脏页,以及其数据I/O传送是否正在进行.


## 把块存放在Page Cache中
VFS和各种文件系统以叫做"块"的逻辑单位组织磁盘数据.在Linux内核的旧版本中,主要有两种不同的磁盘高速缓存:Page Cache(页高速缓存)和缓冲区高速缓存(Buffer Cache),前者用来存放访问磁盘文件内容时生成的磁盘数据页,后者把通过VFS访问的块的内容保留在内存中.<br>

从2.4.10的稳定版本开始,Buffer Cache(缓冲区高速缓存)其实就不存在了.事实上,由于效率的原因,不再单独分配块缓冲区;相反,把他们存放在叫做"缓冲区页"的专门页中,而缓冲区页保存在Page Cache(页高速缓存中).<br>

缓冲区页在形式上就是与称作"缓冲区首部"的附加描述符相关的数据页,其主要目的是快速确定页中的一个块在磁盘中的地址.实际上,Page Cache内的页中的一大块数据在磁盘上的地址不一定是相邻的.<br>

每个块缓冲区都有buffer_head类型的缓冲区首部描述符.该描述符包含内核必须了解的,有关如何处理块的所有信息.


## 通过Page Cache读写基本流程
当内核必须单独地访问一个块时,就涉及存放块缓冲区的缓冲区页,并检查相应的缓冲区首部.下面是内核创建缓冲区页的两种普通情况:
*	当读或写的文件页在磁盘快中不相邻时.(发生这种情况是因为文件系统为文件分配了非连续的块,或者因为文件有"洞")
*	当访问一个单独的磁盘块时.这种情况的一个应用实例是:如果VFS要读大小为1024字节的索引节点块.内核并不是只分配一个单独的块缓冲区,而是必须分配一个整页,从而存放四个缓冲区;这些缓冲区将存放块设备上相邻的4块数据,其中包括所请求的索引节点块.

<br>
在一个缓冲区页内的所有块缓冲区大小必须相同,因此,在80x86体系结构上,根据块的大小,一个缓冲区页可以包括1~8个块缓冲区.下图展示了一个缓冲区页,其中包含四个块缓冲区和对应的缓冲区首部:
[![](https://s2.ax1x.com/2019/06/23/ZP372d.md.png)](https://imgchr.com/i/ZP372d)

当内核需要读或者写一个单独的物理设备块时,必须检查所请求的块缓冲区是否已经在页高速缓存中.<br>
当内核发现指定块的块缓冲区所在的缓冲区页不在页高速缓存中时,就分配一个新的块设备缓冲区页.<br>
当内核试图获得更多的空闲内存时,就释放块设备缓冲区页.当然,不可能释放有脏缓冲区或上锁的缓冲区页.<br>
内核不断用包含块设备数据的页填充页高速缓存,只要进程修改了数据,相应的页就被标记为脏页.Unix系统允许把脏缓冲区写入块设备的操作延迟执行,因为这种策略可以显著地提高系统的性能.对高速缓存中的页的几次写操作可能只需对相应的磁盘块进行一次缓慢的物理更新就可以满足.此外,写操作没有读操作那么紧迫,因为进程通常是不会由于延迟写而挂起.<br>

一个脏页可能直到最后一刻(即系统关闭时)都一直都留在主存中.然而,从延迟写策略的局限性来看,它有两个主要的缺点:
*	如果发生了硬件错误或电源掉电的情况,那么就无法再获得RAM的内容,因此,从系统启动以来对文件进行的很多修改就会丢失.
*	页高速缓存的大小(由此也包括存放它所需的RAM的大小)就可能要很大.

因此,在下列条件下把脏页刷新(写入)到磁盘:
*	页高速缓存变得太慢,但还需要更多的页,或者脏页的数量已经太多.
*	自从页变成脏页以来已经过去太长时间.
*	进程请求块设备或者特定文件任何待定的变化都进行刷盘.通过调用sync(),fsync()或fdatasync()系统调用来实现.
