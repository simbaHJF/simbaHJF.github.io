---
layout:     post
title:      "linux--process management"
date:       2020-04-24 18:00:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

> 摘自: Linux内核设计与实现


#	进程(Process)

进程(process)就是出于执行期的程序(目标代码存放在某种存储介质上).但进程并不仅仅局限于一段可执行程序代码.通常进程还要包括其他资源,像打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间及一个或多个执行线程,当然还包括用来存放全局变量的数据段等.实际上,进程就是正在执行的程序代码的实时结果.内核需要有效而又透明地管理所有细节.

执行线程,简称线程(thread),是在进程中活动的对象.每个线程都拥有一个独立的程序计数器,进程栈和一组进程寄存器.

**<font color="red">内核调度的对象时线程,而不是进程</font>**

在传统的Unix系统中,一个进程只包含一个线程,但现在的系统中,多线程程序非常普遍.linux并不区分线程和进程,对于linux来说,线程只不过是一种特殊的进程.

**<font color="red">程序本身并不是进程,进程是处于执行期的程序以及相关的资源的总称.</font>**

进程在创建它的时刻开始存活.**<font color="red">在linux中,通常是通过fork()这一系统调用来创建新进程的,它通过复制一个已存在的进程来创建新进程</font>**.调用fork()的进程称为父进程,新进程称为子进程.当该调用结束时,在返回点这个相同位置上,父进程恢复执行,子进程开始执行.fork()系统调用从内核返回两次:一次回到父进程,另一次回到新产生的子进程.

通常,创建新的进程都是为了立即执行新的,不同的程序,而接着调用exec()这组函数就可以创建新的地址空间,并把新的程序载入其中.在现代linux内核中,fork()实际上是通过clone()系统调用来实现的.

最后,程序通过exit()系统调用退出执行.这个函数会终结进程并将占用的资源释放掉.父进程可以通过wait4()系统调用查询子进程是否终结,这其实使得进程拥有了等待特定进程执行完毕的能力.进程退出执行后被设置为将死状态,知道它的父进程调用wait()或者waitpid()为止.



#	进程描述符及任务结构

内核把进程的列表存放在叫做任务队列的双向循环列表中.任务队列中的每一项,其类型为task_struct,称为进程描述符.进程描述符中包含的数据能完整地描述一个正在执行的程序:它打开的文件,进程的地址空间,挂起的信号,进程的状态,还有其他更多信息.


####	分配进程描述符

linux通过slab分配器分配task_struct结构,以此达到对象复用和缓存着色的目的.


####	进程描述符的存放

内核通过一个唯一的进程标识值或PID来标识每个进程.内核把每个进程的PID存放在它们各自的进程描述符中.

在内核中,访问任务通常需要获得指向其task_struct的指针.实际上,内核中大部分处理进程的代码都是直接通过task_struct进行的.因此,通过current宏查找当前正在运行进程的进程描述符的速度就显得尤为重要.硬件体系结构不同,该宏的实现也不同.


####	进程状态

进程描述符中的state域描述了进程的当前状态.系统中的每个进程都必然处于五种进程状态中的一种,该域的值也必须为下列五种状态标志之一:

*	TASK_RUNNING(运行)----进程时可执行的,它或者正在执行,或者在运行队列中等待执行.这是进程在用户空间中执行的唯一可能状态,这种状态也可以应用到内核空间中正在执行的进程.

*	TASK_INTERRUPTIBLE(可中断)----进程正在睡眠(也就是说它被阻塞),等待某些条件的达成.一旦这些条件达成,内核就会把进程状态设置为运行.处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行.

*	TASK_UNINTERRUPTIBLE(不可中断)----除了就算是接收到信号也不会被唤醒或真被投入运行外,这个状态与可中断状态相同.这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现.由于处于此状态的任务对信号不作响应,所以较之可中断状态,使用的较少.

*	_TASK_TRACED----被其他进程跟踪的进程,例如通过ptrace对调试程序进行跟踪.

*	_TASK_STOPPED(停止)----进程停止执行,进程没有投入运行也不能投入运行.通常这种状态发生在接收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU等信号的时候.此外,在调试期间接收到任何信号,都会使进程进入这种状态.

[![JfhLB8.png](https://s1.ax1x.com/2020/04/27/JfhLB8.png)](https://imgchr.com/i/JfhLB8)


####	进程上下文

可执行程序代码是进程的重要组成部分.这些代码从一个可执行文件载入到进程的地址空间执行.一般程序在用户空间执行.当一个程序执行了系统调用或者触发了某个异常,它就陷入了内核空间.此时,我们称内核"代表进程执行"并处于进程上下文中.在此上下文中current宏是有效的(除了进程上下文,还有中断上下文,在中断上下文中,系统不代表进程执行,而是执行一个中断处理程序.不会有进程去干扰这些中断处理程序,所以此时不存在进程上下文).除非在此间隙有更高优先级的进程需要执行并且调度器选择了这个高优先级进程,否则在内核退出的时候,程序会恢复到用户空间,然后继续执行.


####	进程家族树

linux系统的进程之间存在一个明显的继承关系.所有的进程都是PID为1的init进程的后代.内核在系统启动的最后阶段启动init进程.该进程读取系统的初始化脚本并执行其他的相关程序,最终完成系统启动的整个过程.

