---
layout:     post
title:      "linux--process management"
date:       2020-04-24 18:00:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

> 摘自: Linux内核设计与实现


#	进程(Process)

进程(process)就是出于执行期的程序(目标代码存放在某种存储介质上).但进程并不仅仅局限于一段可执行程序代码.通常进程还要包括其他资源,像打开的文件,挂起的信号,内核内部数据,处理器状态,一个或多个具有内存映射的内存地址空间及一个或多个执行线程,当然还包括用来存放全局变量的数据段等.实际上,进程就是正在执行的程序代码的实时结果.内核需要有效而又透明地管理所有细节.

执行线程,简称线程(thread),是在进程中活动的对象.每个线程都拥有一个独立的程序计数器,进程栈和一组进程寄存器.

**<font color="red">内核调度的对象时线程,而不是进程</font>**

在传统的Unix系统中,一个进程只包含一个线程,但现在的系统中,多线程程序非常普遍.linux并不区分线程和进程,对于linux来说,线程只不过是一种特殊的进程.

**<font color="red">程序本身并不是进程,进程是处于执行期的程序以及相关的资源的总称.</font>**

进程在创建它的时刻开始存活.**<font color="red">在linux中,通常是通过fork()这一系统调用来创建新进程的,它通过复制一个已存在的进程来创建新进程</font>**.调用fork()的进程称为父进程,新进程称为子进程.当该调用结束时,在返回点这个相同位置上,父进程恢复执行,子进程开始执行.fork()系统调用从内核返回两次:一次回到父进程,另一次回到新产生的子进程.

通常,创建新的进程都是为了立即执行新的不同的程序,而接着调用exec()这组函数就可以创建新的地址空间,并把新的程序载入其中.在现代linux内核中,fork()实际上是通过clone()系统调用来实现的.

最后,程序通过exit()系统调用退出执行.这个函数会终结进程并将占用的资源释放掉.父进程可以通过wait4()系统调用查询子进程是否终结,这其实使得进程拥有了等待特定进程执行完毕的能力.进程退出执行后被设置为将死状态,直到它的父进程调用wait()或者waitpid()为止.



#	进程描述符及任务结构

内核把进程的列表存放在叫做任务队列的双向循环列表中.任务队列中的每一项,其类型为task_struct,称为进程描述符.进程描述符中包含的数据能完整地描述一个正在执行的程序:它打开的文件,进程的地址空间,挂起的信号,进程的状态,还有其他更多信息.


####	分配进程描述符

linux通过slab分配器分配task_struct结构,以此达到对象复用和缓存着色的目的.


####	进程描述符的存放

内核通过一个唯一的进程标识值或PID来标识每个进程.内核把每个进程的PID存放在它们各自的进程描述符中.

在内核中,访问任务通常需要获得指向其task_struct的指针.实际上,内核中大部分处理进程的代码都是直接通过task_struct进行的.因此,通过current宏查找当前正在运行进程的进程描述符的速度就显得尤为重要.硬件体系结构不同,该宏的实现也不同.


####	进程状态

进程描述符中的state域描述了进程的当前状态.系统中的每个进程都必然处于五种进程状态中的一种,该域的值也必须为下列五种状态标志之一:

*	TASK_RUNNING(运行)----进程是可执行的,它或者正在执行,或者在运行队列中等待执行.这是进程在用户空间中执行的唯一可能状态,这种状态也可以应用到内核空间中正在执行的进程.

*	TASK_INTERRUPTIBLE(可中断)----进程正在休眠(也就是说它被阻塞),等待某些条件的达成.一旦这些条件达成,内核就会把进程状态设置为运行.处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行.

*	TASK_UNINTERRUPTIBLE(不可中断)----除了就算是接收到信号也不会被唤醒或真被投入运行外,这个状态与可中断状态相同.这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现.由于处于此状态的任务对信号不作响应,所以较之可中断状态,使用的较少.

*	_TASK_TRACED----被其他进程跟踪的进程,例如通过ptrace对调试程序进行跟踪.

*	_TASK_STOPPED(停止)----进程停止执行,进程没有投入运行也不能投入运行.通常这种状态发生在接收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU等信号的时候.此外,在调试期间接收到任何信号,都会使进程进入这种状态.

[![JfhLB8.png](https://s1.ax1x.com/2020/04/27/JfhLB8.png)](https://imgchr.com/i/JfhLB8)


####	进程上下文

可执行程序代码是进程的重要组成部分.这些代码从一个可执行文件载入到进程的地址空间执行.一般程序在用户空间执行.当一个程序执行了系统调用或者触发了某个异常,它就陷入了内核空间.此时,我们称内核"代表进程执行"并处于进程上下文中.在此上下文中current宏是有效的(除了进程上下文,还有中断上下文,在中断上下文中,系统不代表进程执行,而是执行一个中断处理程序.不会有进程去干扰这些中断处理程序,所以此时不存在进程上下文).除非在此间隙有更高优先级的进程需要执行并且调度器选择了这个高优先级进程,否则在内核退出的时候,程序会恢复到用户空间,然后继续执行.


####	进程家族树

linux系统的进程之间存在一个明显的继承关系.所有的进程都是PID为1的init进程的后代.内核在系统启动的最后阶段启动init进程.该进程读取系统的初始化脚本并执行其他的相关程序,最终完成系统启动的整个过程.

系统中的每个进程必有一个父进程,相应的,每个进程也可以拥有零个或多个子进程.拥有同一个父进程的所有进程被称为兄弟.进程间的关系存放在进程描述符中.每个task_struct都包含一个指向其父进程task_struct的指针,叫做parent的指针.还包含一个称为children的子进程链表.



#	进程创建

Linux把进程创建步骤分解到两个单独的函数中取执行:fork()和exec().首先,fork()通过拷贝当前进程创建一个子进程.子进程与父进程的区别仅仅在于PID(每个进程唯一),PPID(父进程的进程号,子进程将其设置为被拷贝进程的PID)和某些资源和统计量(例如,挂起的信号,它没有必要被继承).exec()函数负责读取可执行文件并将其载入地址空间开始运行.


####	写时拷贝

传统的fork()系统调用直接把所有的资源赋值给创建的进程.这种实现过于简单并且效率低下,因为它拷贝的数据也许并不共享,更糟的情况是,如果新进程打算立即执行一个新的映像,那么所有的拷贝都将前功尽弃.linux的fork()使用写时拷贝(copy-on-write)页实现.写时拷贝是一种可以推迟甚至免除拷贝数据的技术.内核此时并不复制整个进程地址空间,而是让父进程和子进程共享同一个拷贝.

只有在需要写的时候,数据才会被复制,从而使各个进程拥有各自的拷贝.也就是说,资源的复制只有在需要写入的时候才进行,在此之前,只是以只读方式共享.这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才进行.在页根本不会被写入的情况下,它们就无需复制了.

fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符.在一般情况下,进程创建后都会马上运行一个可执行的文件,这种优化可以避免拷贝大量根本就不会被使用的数据.



#	线程在linux中的实现

linux实现线程的机制非常独特.从内核的角度来说,它并没有线程这个概念.linux把所有的线程都当做进程来实现.内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程.相反,线程仅仅被视为一个与其他进程共享某些资源的进程.每个线程都拥有唯一隶属于自己的task_struct,所以在内核中,它看起来就像是一个普通的进程(只是线程和其他一些进程共享某些资源,如地址空间).



####	内核线程

内核经常需要在后台执行一些操作.这种任务可以通过内核线程(kernel thread)完成----独立运行在内核空间的标准进程.内核线程和普通进程间的区别在于内核线程没有独立的地址空间.他们只在内核空间运行,从来不切换到用户空间去.内核进程和普通进程一样,可以被调度,也可以被抢占.

内核线程也只能由其他内核线程创建.内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的.



#	进程终结

当一个进程终结时,内核必须释放它所占有的资源,并将它的消亡通知给其父进程.一般来说,进程的析构是自身引起的.它发生在进程调用exit()系统调用时,既可能显示地调用这个系统调用,也可能隐式地从程序的主函数返回(C语言编译器会在main()函数的返回点后面放置调用exit()的代码).当进程接收到它既不能处理也不能忽略的信号或异常时,它还可能被动地终结.


####	孤儿进程造成的进退维谷

如果父进程在子进程之前退出,必须有机制来保证子进程能找到一个新的父进程,否则这些成为孤儿的进程就会在退出时永远处于僵死状态,白白地耗费内存.对于这个问题,解决方法是给子进程在当前线程组内找一个线程作为父亲,如果不行,就让init做他们的父进程.