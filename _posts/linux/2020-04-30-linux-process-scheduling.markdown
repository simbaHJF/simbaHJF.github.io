---
layout:     post
title:      "linux--process scheduling"
date:       2020-04-24 18:00:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - linux

---

> 摘自: Linux内核设计与实现


#	多任务

多任务系统可以划分为两类:

*	非抢占式多任务(cooperative multitasking)
*	抢占式多任务(preemptive multitasking)

linux属于抢占式的多任务模式.在此模式下,由调度程序来决定什么时候停止一个进程的运行,以便其他进程能够得到执行机会.这个强制的挂起动作就叫做抢占.进程在被抢占之前能够运行的时间是预先设置好的,而且有一个专门的名字,叫做进程时间片(timeslice).时间片实际上就是分配给每个可运行进程的处理器时间段.有效管理时间片能使调度程序从系统全局的角度做出调度决定,这样做还可以避免个别进程独占系统资源.当今众多现代操作系统对程序运行都采用了动态时间片计算的方式,并且引入了可配置的计算策略.

相反,在非抢占式多任务模式下,除非进程自己主动停止运行,否则它会一直执行.进程主动挂起自己的操作称为让步(yielding).理想情况下,进程通常会做出让步,以便让每个可运行进程享有足够的处理器时间.但这种机制有很多缺点:调度程序无法对每个进程该执行多长时间做出统一规定,所以进程独占的处理器时间可能超出用户的预料;更糟的是,一个绝不做出让步的挂起进程可能会使系统崩溃.



#	linux的进程调度

linux2.4及其以前版本中内核中,调度程序相当简陋,设计原始,各种场景难以胜任.

linux2.5版本内核,对调度程序作了大手术.开始采用一种叫做O(1)调度程序的新调度程序----因其算法的行为而得名.它解决了先前版本linux调度程序的许多不足,引入了许多强大的新特性和性能特征.这里主要归功于静态时间片算法和针对每一处理器的运行队列.

O(1)调度器在数十量级(不是数百量级)的多处理器的环境下尚能表现出近乎完美的性能和可扩展性,但该调度算法对于那些响应时间敏感的程序方面有不足.这些程序我们称其为交互进程----它无疑包括了所有需要用户交互的程序.

linux2.6版本内核中,为了提高对交互程序的调度性能引入了新的进程调度算法.其中最著名的是"反转楼梯最后期限调度算法",该算法吸收了队列理论,将公平调度的概念引入了linux调度程序.并最终在2.6.23内核版本中替代了O(1)调度算法,它此刻被称为"完全公平调度算法",简称CFS



#	策略

策略决定调度程序在何时让什么进程运行.调度器的策略往往就决定系统的整体印象,并且,还要负责优化使用处理器时间.无论从哪个方面来看,他都是至关重要的.


####	I/O消耗型和处理器消耗型的进程

进程可以被分为I/O消耗型和处理器消耗型.

I/O消耗型指进程的大部分时间用来提交I/O请求或是等待I/O请求.因此,这样的进程经常处于可运行状态,但通常都是运行短短的一会儿,因为它在等待更多的I/O请求时总会阻塞(这里所说的I/O是指任何类型的可阻塞资源,比如键盘输入,或者是网络I/O).

处理器消耗型进程把时间大多用在执行代码上.除非被抢占,否则他们通常都一直不停地运行,因为他们没有太多的I/O需求.但是,因为他们不属于I/O驱动类型,所以从系统响应速度考虑,调度器不应该经常让他们运行.对于这类处理器消耗型的进程,调度策略往往是尽量降低他们的调度频率,而延长其运行时间.

调度策略通常要在两个矛盾的目标中寻找平衡:进程响应迅速(响应时间短)和最大系统利用率(高吞吐量).为了满足上述需求,调度程序通常采用一套非常复杂的算法来决定最值得运行的进程投入运行,但是它往往并不保证低优先级进程会被公平对待.linux更倾向于优先调度I/O消耗型进程.虽然如此,调度程序也并未忽略处理器消耗型的进程.


####	进程优先级

调度算法中最基本的一类就是基于优先级的调度.这是一种根据进程的价值和其对处理器时间的需求来对进程分级的思想.通常做法是(其并未被linux系统完全采用)优先级高的进程先运行,低的后运行,相同优先级的进程按轮转方式进行调度(一个接一个,重复进行).在某些系统中,优先级高的进程使用的时间片也较长.调度程序总是选择时间片未用尽而且优先级最高的进程运行.用户和系统都可以通过设置进程的优先级来影响系统的调度.

linux采用了两种不同的优先级范围:
*	nice值----范围是从-20到+19,默认为0.越大的nice值意味着更低的优先级.
*	实时优先级----其值是可配置的,默认情况下它的变化范围是从0到99(包括0和99).越高的实时优先级数值意味着进程优先级越高.



####	时间片

时间片是一个数值,它表明进程在被抢占前所能持续运行的时间.调度策略必须规定一个默认的时间片,但这并不是件简单的事.时间片过长会导致系统对交互的响应表现欠佳;时间片太短会明显增大进程切换带来的处理器耗时.此外,I/O消耗型进程不需要长的时间片;而处理器消耗型的进程则希望时间片越长越好(比如这样可以让它们的告诉缓存命中率更高)

linux的CFS调度器并没有直接分配时间片到进程,它是将处理器的使用比例划分给了进程.这样一来,进程所获得的处理器时间其实是和系统负载密切相关的.这个比例进一步还会受进程nice值的影响,nice值作为权重将调整进程所使用的处理器时间比.具有更高nice值的进程将被赋予地权重;具有更小nice值的进程则会被赋予高权重,从而抢得更多的处理器使用比.

linux系统是抢占式的.当一个进程进入可运行态,它就被准许投入运行.在多数操作系统中,是否将一个进程立刻投入运行,是完全有进程优先级决定的.而在linux中使用的Cfs调度器,其抢占时机取决于新的可运行程序消耗了多少处理器使用比.如果消耗的使用比比当前进程小,则新进程立刻投入运行,抢占当前进程.否则,将推迟其运行.


#	linux调度算法

####	调度器类

linux调度器是以模块方式提供的,这样做的目的是允许不同类型的进程可以有针对性地选择调度算法.这种模块化结构被称为调度器类(scheduler classes),它允许多种不同的可动态添加的调度算法并存,调度属于自己范畴的进程.每个调度器都有一个优先级,基础的调度器代码会按照优先级顺序遍历调度类,拥有一个可执行进程的最高优先级的调度器类胜出,去选择下面要执行的那一个程序.

完全公平调度----CFS,是一个针对普通进程的调度类,普通进程在linux中标记为SCHED_NORMAL.

**<font color="red">后面还会讲实时调度策略,实时调度的进程就不再是通过CFS来调度的了.</font>**

####	公平调度

CFS的出发点基于一个简单的理念:进程调度的效果应如同系统具备一个理想中的完美多任务处理器.在这种系统中,每个进程将能获得1/n的处理器时间----n是指可运行进程的数量.同时,调度给它们无限小的时间周期,所以在任何可测定周期内,将会给予n个进程中每个进程同样多的运行时间.举例来说,假如我们有两个运行进程,在标准Unix调度模型中,我们先运行其中一个5ms,然后再运行另一个5ms.但他们任何一个运行时都将占有100%的处理器.而在理想情况下,完美的多任务处理器模型应该是这样的:能在10ms内同时运行两个进程,它们各自使用处理器一半的能力.后面这种模型称为----完美多任务.

上述理想模型并非现实,因为无法在一个处理器上真的同时运行多个进程.而且如果每个进程运行无限小的时间周期也是不高效的----抢占消耗(进程切换,缓存命中效率).CFS的做法是允许每个进程运行一段时间,循环轮转,选择运行最少的进程作为下一个运行进程,而不再采用分配给每个进程时间片的做法.

CFS在所有可运行进程总数基础上计算出一个进程应该运行多久,而不是依靠nice值来计算的时间片.nice值在CFS中被作为进程获得的处理器运行比的权重:越高的nice值(越低的优先级),进程获得更低的处理器使用权重,;越低的nice值(越高的优先级)的进程获得更高的处理器使用权重.

每个进程都按其权重在全部可运行进程中所占比例的"时间片"来运行,为了计算准确的时间片,CFS为完美多任务中的无限小调度周期的近似值设立了一个目标.而这个目标称作"目标延迟",越小的调度周期将带来越好的交互性,同时也更接近完美的多任务,但同时也必须承受更高的切换代价和更差的系统总吞吐能力.我们假定目标延迟是20ms,有两个同样优先级的可运行任务,每个任务在被其他任务抢占前运行10ms;如果有4个这样的任务,则每个只能运行5ms;进一步,如果有20个这样的任务,那么每个仅仅只能获得1ms的运行时间.
**<font color="red">相当于,所有可运行进程按比例分割这20ms,而每20ms为一个周期,循环.而不再是nice值到运行时间的直接映射(nice值0映射100ms,nice值19映射5ms这种)</font>**

当可运行任务数量趋于无限时,他们各自所获得的处理器使用比和时间片都将趋于0.这样无疑造成了不可接受的切换消耗.CFS为此引入每个进程获得的时间片底线,这个底线称为最小粒度,默认情况下这个值是1ms.如此,即便是可运行进程数量趋于无穷,每个最少也能获得1ms的运行时间,确保切换消耗被限制在一定范围内.

任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定.CFS称为公平调度器是因为它确保给每个进程公平的处理器使用比.CFS不是完美的公平,它只是近乎完美的多任务.但是它确实在多进程环境下,降低了调度延迟带来的不公平性



#	linux调度的实现

####	时间记账

所有的调度器都必须对进程运行时间做记账.多数Unix系统都是这样做的,它是通过分配时间片给进程来实现时间记账的.当每次系统时钟节拍发生时,时间片都会减少一个节拍周期.当一个进程的时间片被减少到0时,它就会被另一个尚未减到0的时间片可运行进程抢占.

CFS不再有时间片的概念,但是它也必须维护每个进程运行的时间记账,因为它需要确保每个进程只在公平分配给它的处理器时间内运行.

在CFS使用的调度器实体结构中,用vruntime变量存放进程的虚拟运行时间,该运行时间的计算是经过了所有可运行进程总数的标准化.虚拟时间是以ns为单位的,所以vruntime和定时器节拍不再相关.虚拟运行时间可以帮助我们逼近CFS模型所追求的"理想多任务处理器".因此CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久.


####	进程选择

由于我们没法在现实中找到一个前面谈到的理想中的完美多任务处理器,因此CFS试图利用一个简单的规则去均衡进程的虚拟行时间:当CFS需要选择下一个运行进程时,它会挑一个具有最小vruntime的进程.这其实就是CFS调度算法的核心:选择具有最小vruntime的任务.CFS使用红黑树来组织可运行进程队列,并利用其迅速找到最小vruntime值的进程.


####	调度器入口

进程调度的主要入口点是函数schedule().它正是内核其他部分用于调用进程调度器的入口:选择哪个进程可以运行,何时将其投入运行.schedule()通常都需要和一个具体的调度类相关联,它会找到一个最高优先级的调度类----后者需要有自己的可运行队列,然后问后者谁才是下一个该运行的进程.


####	睡眠和唤醒

休眠(被阻塞)的进程处于一个特殊的不可执行状态.这点非常重要,如果没有这种特殊状态的话,调度程序就可能选出一个本不愿意被执行的进程,更糟糕的是,休眠就必须以轮询的方式实现了.

进程休眠有多种原因,但肯定都是为了等待一些事件.事件可能是一段时间从文件I/O读更多数据,或者是某个硬件事件.一个进程还有可能在尝试获取一个已被占用的内核信号量时被迫进入休眠.

无论哪种情况,内核的操作都相同:进程把自己标记成休眠状态,从可执行红黑树中移出,放入等待队列,然后调用schedule()选择和执行一个其他进程.唤醒的过程刚好相反:进程被设置为可执行状态,然后再从等待队列中移到可执行红黑树中.

**<font color="red">这颗红黑树,就是可执行队列</font>**

之前有讨论过,休眠有两种相关的进程状态:
*	TASK_INTERRUPTIBLE
*	TASK_UNINTERRUPTIBLE

它们的唯一区别是处于TASK_UNINTERRUPTIBLE的进程会忽略信号,而处于TASK_INTERRUPTIBLE状态的进程如果接收到一个信号,会被提前唤醒并响应信号.两种状态的进程位于同一个等待队列上,等待某些事件,不能够运行.

**1.等待队列**

休眠通过等待队列进行处理.等待队列是由等待某些事件发生的进程组成的简单链表.进程把自己放入等待队列中并设置成不可执行状态.当与等待队列相关的事件发生的时候,队列上的进程会被唤醒.

**<font color="red">我理解,等待队列应该不是只有一个,而是有多个,等待相同事件的进程放入同一等待队列中</font>**

**2.唤醒**

唤醒操作通过函数wake_up()进行,它会唤醒指定的等待队列上的所有进程.它调用函数try_to_wake_up(),该函数负责将进程设置为TASK_RUNNING状态,调用enqueue_task()将此进程放入红黑树(可执行队列)中,如果被唤醒的进程优先级比当前正在执行的进程的优先级高,还要设置need_resched标志.通常,哪段代码促使等待条件达成,他就要负责随后调用wake_up()函数.例如,当磁盘数据到来时,VFS就要负责对等待队列调用wake_up(),以便唤醒队列中等待这些数据的进程.

下图描述了每个调度程序状态之间的关系:
**<font color="red">对下图说明一点,放入等待队列后,把任务状态设置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE</font>**
![YCY7uQ.png](https://s1.ax1x.com/2020/05/04/YCY7uQ.png)



#	抢占和上下文切换

上下文切换,就是从一个可执行进程切换到另一个可执行进程,由context_switch()函数负责处理.每当一个新的进程被选出来准备投入运行的时候,schedule()就会调用该函数.它完成两项基本工作:
*	把虚拟内存映射从上一个进程切换到新进程
*	从上一个进程的处理器状态切换到新进程的处理器状态.这包括保存,恢复栈信息和寄存器信息,还有其他任何与体系结构相关的状态信息,都必须以每个进程为对象进行管理和保存.

内核必须知道在什么时候调用schedule().如果仅靠用户程序代码显式地调用schedule(),它们可能就会永远地执行下去.取而代之,内核提供了一个need_resched标志来表明是否需要重新执行一次调度.当某个进程应该被抢占时,scheduler_tick()就会设置这个标志;当一个优先级高的进程进入可执行状态的时候,try_to_wake_up()也会设置这个标志,内核检查该标志,确认其被设置,调用schedule()来切换到一个新的进程.该标志对于内核来讲是一个信息,它表示有其他进程应当被运行了,要尽快调度程序.

在返回用户空间以及从中断返回的时候,内核也会检查need_resched标志.如果已被设置,内核会在继续执行之前调用调度程序.need_resched标志是包含在每个进程中的,而不是全局的,这是因为访问进程描述符内的数值要比访问一个全局变量快(因为current宏速度很快并且描述符通常都在高速缓存中).


####	用户抢占

内核即将返回用户空间的时候,如果need_resched标志被设置,会导致schedule()被调用,此时就会发生用户抢占.在内核返回用户空间的时候,它知道自己是安全的,因为既然它可以继续执行当前进程,那么它当然可以再去选择一个新的进程去执行.所以,内核无论是在中断处理程序还是在系统调用后返回,都会检查need_resched标志.如果它被设置了,那么内核会选择一个其他(更合适的)进程投入运行.

简而言之,用户抢占在以下情况时产生:
*	从系统调用返回用户空间时
*	从中断处理程序返回用户空间时


####	内核抢占

与其他大部分的Unix变体和其他大部分操作系统不同,linux内核是完全抢占式的.在非抢占式内核中,内核代码可以一直执行,直到它完成为止.调度程序没有办法在一个内核级的任务正在执行的时候重新调度----内核中的各任务是以协作方式调度的,不具备抢占性.内核代码一直要执行到完成(返回用户空间)或明显的阻塞为止.在2.6内核版本中,引入了抢占.现在,只要重新调度是安全的,内核就可以在任何时间抢占正在执行的任务.那么,什么时候重新调度才是安全的呢?只要没有持有锁,正在执行的代码就是可重新导入的,也就是可以抢占的.

如果内核中的进程被阻塞了,或它显式地调用了schedule(),内核抢占也会显式地发生.如果代码显式地调用了schedule(),那么它应该清楚自己是可以安全地被抢占的.

内核抢占会发生在:
*	中断处理程序正在执行,且返回内核空间之前
*	内核代码再一次具有可抢占性的时候
*	如果内核中的任务显式地调用schedule()
*	如果内核中的任务阻塞(这同样也会导致调用schedule())



#	实时调度策略

linux提供了两种实时调度策略:SCHED_FIFO和SCHED_RR.而普通的,非实时的调度策略是SCHED_NORMAL.借助调度类的框架,这些实时策略并不被完全公平调度器来管理,而是被一个特殊的实时调度器管理.

SCHED_FIFO实现了一种简单的,先入先出的调度算法,它不使用时间片.处于可运行状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度.

**<font color="red">一旦一个SCHED_FIFO级进程处于可执行状态,就会一直执行,直到它自己受阻塞或显式地释放处理器为止;它不基于时间片,可以一直执行下去.只有更高优先级的SCHED_FIFO或者SCHED_RR
任务才能抢占SCHED_FIFO任务.如果有两个或者更多的同优先级的SCHED_FIFO级进程,它们会轮流执行,但是依然只有在它们愿意让出处理器时才会退出.只要有SCHED_FIFO级进程在执行,其他级别较低的进程就只能等待它变为不可运行状态后才有机会执行.</font>**

SCHED_RR与SCHED_FIFO大体相同,只是SCHED_RR级的进程在耗尽事先分配给它的时间后就不能再继续执行了.也就是说,SCHED_RR是带有时间片的SCHED_FIFO----这是一种实时轮流调度算法.当SCHED_RR任务耗尽它的时间片时,在同一优先级的其他实时进程被轮流调度.时间片只是用来重新调度同一优先级的进程.和SCHED_FIFO进程一样,高优先级总是立即抢占低优先级,但低优先级进程决不能抢占SCHED_RR任务,即使它的时间片耗尽.

这两种实时算法实现的都是静态优先级.内核不为实时进程计算动态优先级.这能保证给定优先级别的实施进程总能抢占优先级比它低的进程.

linux的实时调度算法提供了一种软实时工作方式.软实时的含义是,内核调度进程,尽力使进程在它的限定时间到来前运行,但内核不保证总能满足这些进程的要求.相反,硬实时系统保证在一定条件下,可以满足任何调度的要求.linux对于实时任务的调度不做任何保证(但是其性能还是不错的,可以满足严格的时间要求).

实时优先级范围从0到MAX_RT_PRIO减1.默认情况下,MAX_RT_PRIO为100----所以默认的实时优先级范围是从0到99.SCHED_NORMAL级进程的nice值共享了这个取值空间,它的取值范围是从MAX_RT_PRIO到(MAX_RT_PRIO + 40).也就是说,在默认情况下,nice值从-20到+19直接对应的是从100到139的实时优先级范围.