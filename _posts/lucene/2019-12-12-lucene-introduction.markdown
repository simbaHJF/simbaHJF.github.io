---
layout:     post
title:      "Lucene简介"
date:       2019-12-12 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - lucene

---

> 参考:	
> 开放源代码的全文检索引擎Lucene
> https://blog.csdn.net/njpjsoftdev/article/details/54015485  
> https://blog.csdn.net/yunqiinsight/article/details/80008394  


#	总论

根据[http://lucene.apache.org/core/index.html](http://lucene.apache.org/core/index.html)的定义:Lucene是一个高效的,基于Java的全文检索库.所以在了解Lucene之前先来了解一下什么是全文检索.<br>

我们常用的数据总体分成两种:结构化数据和非结构化数据.
*	结构化数据: 指具有固定格式或有限长度的数据,如数据库,元数据等.
*	非结构化数据:	指不定长或无固定格式的数据,如邮件,word文档等.
<br>

当然有的地方还有提到第三种,半结构化数据,如XML,HTML等,根据需要可按结构化数据来对其进行处理,也可抽取出纯文本按非结构化数据来处理.<br>


按照数据的分类,搜索数据页分为两种:
*	对结构化数据的搜索:如对关系型数据库的搜索,用SQL语句等
*	对非结构化数据的搜索(也就是全文检索):如利用windows的搜索可以搜索文件内容;Linux下的grep命令;Google和百度搜索大量内容数据.
<br>

对非结构化数据的搜索主要有两种方法:<br>

一种是顺序扫描法.所谓顺序扫描法,就是当要查找内容包含某一个字符串的文件,就一个文档一个文档的进行查找,对于每个文档,从头查找到尾,如果此文档包含该字符串,则此文档为我们要找的文件,接着对下一个文档进行查找,直到扫描完所有的文件.这种方法比较原始,但对于小数据量的文件,这种方式还是最直接方便的.但是对于大量的文件,这种方式会相当的慢.<br>

另一种便是全文检索技术.全文检索的基本思路是,将非结构化数据中的一部分信息提取出来,重新组织,使其变得有一定的结构,然后对此有一定结构的数据进行搜索,从而达到搜索相对较快的目的.这部分从非结构化数据中提取出的然后重新组织的信息,称之为索引.类比字典的查找过程,先通过拼音索引找到对应字的页,进而找到字相关的解释文档.<br>

这种先建立索引,再对索引进行搜索的过程就称为全文检索.下面的图来自<<Lucene in action>>,但却不仅仅描述了Lucene的检索过程,而是描述了全文检索的一般过程.
![Z3KQqP.png](https://s2.ax1x.com/2019/06/30/Z3KQqP.png)

全文检索大体分为两个过程,索引创建和搜索索引.
*	索引创建:	将现实世界中所有的结构化和非结构化数据提取信息,创建索引的过程.
*	搜索索引:	就是得到用户的查询请求,搜索创建的索引,然后返回结果的过程.
<br>



#	索引原理

顺序扫描速度慢的原因是:我们想要搜索的信息和非结构化数据中存储的信息不一致.非结构化数据中所存储的信息是每个文件包含那些字符串,即已知文件,欲求字符串相对容易,是一种从文件到字符串的映射.而我们想要搜索的信息是那些文件包含给定字符串,即已知字符串,欲求文件的过程,是一种从字符串到文件的映射.两者恰恰相反.因此,如果索引总能够保存从字符串到文件的映射,则会大大提高搜索速度.由于从字符串到文件的映射是文件到字符串映射的反向过程,于是保存这种信息的索引称为反向索引(倒排索引).<br>

反向索引所保存的信息一般如下:<br>

假设我的文档集合里面有100篇文档,为了方便表示,我们为文档从1到100进行编号,得到下面的倒排索引结构:
![Z3lMrR.png](https://s2.ax1x.com/2019/06/30/Z3lMrR.png)

左边保存的是一系列字符串,称为词典.每个字符串都指向包含此字符串的文档链表,此文档链表称为倒排表.有了倒排索引,便使保存到信息和要搜索的信息一致了,可以大大加快搜索的速度.比如当需要查找既包含字符串"lucene"又包含字符串"solr"的文档,只需要以下几步:
*	取出包含字符串"lucene"的文档链表
*	取出包含字符串"solr"的文档链表
*	通过合并链表,找出既包含"lucene"又包含"solr"的文件.
<br>

过程如下图所示:
![Z3lXLR.png](https://s2.ax1x.com/2019/06/30/Z3lXLR.png)

由此可见,全文检索有一个预先建立索引的过程,如果索引的数据量很大,创建索引的过程也会相对较慢,但创建索引的过程只需要一次,以后的查询过程就只需要搜索创建好的索引就可以了.这也是全文检索相对于顺序扫描的又是之一:一次索引,多次使用.<br>


在倒排索引中,词典结构尤为重要,有很多种词典结构,各有各的优缺点,最简单如排序数组,通过二分查找来检索数据,更快的有哈希表,磁盘查找有B树和B+树,但一个能支持TB级数据的倒排索引结构需要在时间和空间上有个平衡,下表列出了一些常见词典的优缺点:

数据结构 | 优缺点 |
-|-|
排序列表 | 实现简单;但性能差 |
哈希表 | 性能高;但内存消耗大,几乎是原始数据的三倍 |
跳跃表 |	占内存小,且可调;但对模糊查询支持不好 |
B树 | 磁盘索引,更新方便;但检索速度慢,数据库应用较多 |
字典树 | 查询效率只跟字符串长度有关;但只适合英文词典 |
Finite State Transducers(FST) | 共享前缀,内存消耗小;但要求输入有序更新不易 |

其中可用的有B+树,跳跃表,FST

B+树:
![Q6s1YQ.png](https://s2.ax1x.com/2019/12/12/Q6s1YQ.png)

> 理论基础:	平衡多路查找树  
> 优点:	外存索引,可更新  
> 缺点:	空间大,速度不够快  


跳跃表:
![Q6gBHx.png](https://s2.ax1x.com/2019/12/12/Q6gBHx.png)

> 优点:	结构简单,跳跃间隔,级数等可控,Lucene 3.0之前使用的也是跳跃表结构,后换成了FST,但跳跃表在Lucene其他地方还有应用如倒排表合并和文档号索引.  
> 缺点:	模糊查询支持不好


FST:
Lucene 4.0后使用的词典索引结构
![Q62Vq1.png](https://s2.ax1x.com/2019/12/12/Q62Vq1.png)

> 理论基础:	<<Direct construction of minimal acyclic subsequential transducers>>,通过输入有序字符串构建最小有向无环图.  
> 优点:	内存占用率低,压缩率一般在3倍~20倍之间,查询快,模糊查询支持好.  
> 缺点:	结构复杂,输入要求有序,更新不易.  
> 注:	Lucene 4中有开源实现.从对外接口上看,它跟Map结构很相似,有查找,有迭代



FST 100万数据性能测试:

数据结构 | 构建时间(ms) | 查询所有key(ms) |
-|-|-|
HashMap | 185 | 106 |
TreeMap | 500 | 218 |
FST | 1512 | 890 |

由此可见,FST性能和HashMap的差距不大,但FST有个不可比拟的优势就是占用内存小,只有HashMap的十分之一左右,这对大数据规模检索是至关重要的,毕竟速度再快放不进内存也是没用的.

因此,一个合格的词典结构有以下要求:
*	查询速度
*	内存占用
*	内存+磁盘结合


由词典FST和倒排表SkipList的结合,索引查询的过程可用下图来描述:
![Q6fgot.png](https://s2.ax1x.com/2019/12/12/Q6fgot.png)







#	索引实现

**<font color="red">基于Lucene 4</font>**

Lucene的索引文件结构,基本可以分为三个部分:词典,倒排表,正向文件,列式存储DocValues.如下图:
![Q6W4bR.png](https://s2.ax1x.com/2019/12/12/Q6W4bR.png)


##	索引结构

Lucene现在采用的数据结构为FST,它的特点是:
*	次查找复杂度为O(log length)
*	共享前缀,节省空间
*	内存存放前缀索引,磁盘存放后缀词块

我们往索引库里插入四个单词abd,abe,acf,acg,来看看它的索引文件内容
![Q6oGUs.png](https://s2.ax1x.com/2019/12/12/Q6oGUs.png)

tip部分,每列一个FST索引,所以会有多个FST,每个FST存放前缀和后缀块指针,这里前缀就为a,ab,ac.<br>
tim里面存放后缀块和词的其他信息如倒排表指针,TFDF等.<br>
doc文件里就位每个单词的倒排表.  

所以它的检索过程分为三个步骤:  
1.	内存加载tip文件,通过FST匹配前缀找到后缀词块位置.
2.	根据词块位置,读取磁盘中tim文件中后缀块并找到后缀和相应的倒排表位置信息.
3.	根据倒排表位置去doc文件中加载倒排表.


这里有两个问题,第一就是前缀如何计算,第二就是后缀如何写磁盘并通过FST定位,下面将描述Lucene构建FST过程.  
已知FST要求输入有序,所以Lucene会将解析出来的文档单词预先排序,然后构建FST,我们假设输入abd,abe,acf,acg,那么整个构建过程如下:
![Q6HiuT.png](https://s2.ax1x.com/2019/12/12/Q6HiuT.png)

> 1.	插入abd时,没有输出.  
> 2.	插入abe时,计算出前缀ab,但此时不知道后续还不会有其他以ab为前缀的词,所以此时无输出.  
> 3.	插入acf时,因为是有序的,知道不会再有ab前缀的词了,这时就可以写tip和tim了,tim中写入后缀词块d、e和它们的倒排表位置ip_d,ip_e. tip中写入a,b和以ab为前缀的后缀词块位置(真实情况下会写入更多信息如词频等).  
> 4.	插入acg时,计算出和acf共享前缀ac,这时输入已经结束,所有数据写入磁盘.tim中写入后缀词块f、g和相对应的倒排表位置,tip中写入c和以ac为前缀的后缀词块位置.  

以上是一个简化过程,Lucene的FST实现的主要优化策略有:
> 1.	最小后缀数.Lucene对写入tip的前缀有个最小后缀数要求,默认25,这是为了进一步减少内存使用.如果按照25的后缀数,那么就不存在ab、ac前缀,将只有一个跟节点,abd、abe、acf、acg将都作为后缀存在tim文件中.我们的10g的一个索引库,索引内存消耗只占20M左右.  
> 2.	前缀计算基于byte,而不是char,这样可以减少后缀数,防止后缀数太多,影响性能.如对宇(e9 b8 a2)、守(e9 b8 a3)、安(e9 b8 a4)这三个汉字,FST构建出来,不是只有根节点,三个汉字为后缀,而是从unicode码出发,以e9、b8为前缀，a2、a3、a4为后缀,如下图:  

![Q6qcj0.png](https://s2.ax1x.com/2019/12/12/Q6qcj0.png)  


##	倒排表结构

倒排表就是文档号集合,但怎么存,怎么取也有很多讲究,Lucene现在使用的倒排表结构叫做Frame of Reference and Roaring Bitmaps,它主要有两个特点:

1.	数据压缩,可以看下图怎么将6个数字从原先的24bytes压缩到7bytes
![QgUMBF.png](https://s2.ax1x.com/2019/12/13/QgUMBF.png)

2.	跳跃表加速合并,因为布尔查询时,and 和 or 操作都需要合并倒排表,这是就需要快速定位相同文档号,所以利用跳跃表来进行相同文档号查找.


##	正向文件

正向文件指的就是原始文档,Lucene对原始文档也提供了存储功能,它存储特点就是:分块+压缩.fdt文件就是存放原始文档的文件,它占了索引库90%的磁盘空间,fdx文件为索引文件,通过文档号(自增数字)快速得到文档位置,它们的文件结构如下:  
![QganPA.png](https://s2.ax1x.com/2019/12/13/QganPA.png)

fnm中为元信息存放了各列类型、列名、存储方式等信息.

fdt为文档值,里面一个chunk就是一个块,Lucene索引文档时,先缓存文档,缓存大于16KB时,就会把文档压缩存储.一个chunk包含了该chunk起始文档、多少个文档、压缩后的文档内容.

fdx为文档号索引,倒排表存放的时文档号,通过fdx才能快速定位到文档位置即chunk位置,它的索引结构比较简单,就是跳跃表结构,首先它会把1024个chunk归为一个block,每个block记载了起始文档值,block就相当于一级跳表.

所以查找文档,就分为三步:

*	第一步查找block,定位属于哪个block.
*	第二步就是根据从block里根据每个chunk的起始文档号,找到属于哪个chunk和chunk位置.
*	第三步就是去加载fdt的chunk,找到文档.

从上面分析可以看出,lucene对原始文件的存放是行是存储,并且为了提高空间利用率,是多文档一起压缩,因此取文档时需要读入和解压额外文档,因此取文档过程非常依赖随机IO,以及lucene虽然提供了取特定列,但从存储结构可以看出,并不会减少取文档时间.