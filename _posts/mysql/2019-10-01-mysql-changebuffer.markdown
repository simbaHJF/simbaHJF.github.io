---
layout:     post
title:      "mysql -- change buffer"
date:       2019-10-01 13:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - mysql

---

> 极客时间--丁奇--mysql实战 学习笔记


##	change buffer
当需要更新一个数据页时,如果数据页在内存中就直接更新,而如果这个数据页还没有在内存中的话,在不影响数据一致性的前提下,InnoDB会将这些更新操作缓存在change buffer中,这样就不需要从磁盘中读入这个数据页了.在下次查询需要访问这个数据页的时候,将数据页读入内存,然后执行change buffer中与这个页有关的操作.通过这种方式就能保证这个数据逻辑的正确性.

change buffer实际上是可以持久化的数据.也就是说,change buffer在内存中有拷贝,也会被写入到磁盘上.

将change buffer中的操作应用到原数据页,得到最新结果的过程称为merge.除了访问这个数据页会触发merge外,系统有后台线程会定期merge.在数据库正常关闭(shutdown)的过程中也会执行merge操作.

显然,如果能够将更新操作先记录在change buffer,减少读磁盘,语句的执行速度会得到明显的提升.而且数据读入内存是需要占用buffer pool的,所以这种方式还能够避免占用内存,提高内存利用率.

**那么,什么条件下可以使用change buffer呢?**

对于唯一索引来说,所有的更新操作都要先判断这个操作是否违反唯一约束.比如,要插入(4,400)这个记录,就要先判断现在表中是否已经存在k=4的记录,而这必须要将数据页读入内存才能判断.如果都已经读入到内存了,那直接更新内存会更快,就没必要使用change buffer了.

因此,唯一索引的更新不能使用change buffer,实际上只有普通索引可以使用.

按照change buffer的机制,来看一下:如果要在表中插入一个新纪录(4,400)的话,InnoDB的处理流程是怎样的.

第一种情况是,这个记录要更新的目标页在内存中.这时,InnoDB的处理流程如下:
*	对于唯一索引来说,找到3和5之间的位置,判断到没有冲突,插入这个值,语句执行结束;
*	对于普通索引来说,找到3和5之间的位置,插入这个值,语句执行结束.

这样看来,普通索引和唯一索引对更新语句性能影响的差别,只是一个判断,只会消耗微小的CPU时间.因此,这不是我们关注的重点.

第二种情况是,这个记录要更新的目标页不在内存中.这时,InnoDB的处理流程如下:
*	对于唯一索引来说,需要将数据页读入内存,判断到没有冲突,插入这个值,语句执行结束;
*	对于普通索引来说,则是将更新记录在change buffer,语句执行就结束了.

将数据从磁盘读入内存设计随机IO的访问,是数据库里面成本最高的操作之一.change buffer因为减少了随机磁盘访问,所以对更新性能的提升很明显.


##	change buffer的使用场景
merge的时候是真正进行数据更新的时刻,而change buffer的主要目的就是将记录的变更动作缓存下来,所以在一个数据页做merge之前,change buffer记录的变更越多,收益就越大.因此,对于写多读少的业务来说,页在写完以后马上被访问的概率比较小,此时change buffer的使用效果最好.这种业务模型常见的就是账单类,日志类的系统.

反过来,假设一个业务的更新模式是写入之后马上做查询,那么即使满足了条件,将更新先记录在change buffer,但之后由于马上要访问这个数据页,会立即触发merge过程.这样随机访问的IO次数不会减少,反而增加了change buffer的维护代价.所以,这种业务场景下,change buffer反而起到了反作用.



##	change buffer和redo log
有如下插入语句:
```
mysql> insert into t(id,k) values(id1,k1),(id2,k2);

```

这里,假设当前k索引树的状态,查找到位置后,k1所在的数据页在内存中,k2所在的数据页不在内存中.下图是带change buffer的更新状态图:
[![uhhdyt.png](https://s2.ax1x.com/2019/10/08/uhhdyt.png)](https://imgchr.com/i/uhhdyt)

这条更新语句涉及四个部分:内存,redo log,数据表空间(t.idb),系统表空间(ibdata1).

这条更新语句做了如下操作:
1.	page 1 在内存中,直接更新内存;
2.	page 2 没有在内存中,就在内存的change buffer区域,记录下"往page 2插入一行"这个信息
3.	将上述两个动作记入redo log中.

做完这些操作,事务就完成了.可以看到,执行这条更新语句的成本很低,就是写了两处内存,然后写了一处磁盘(两次操作合在一起写了一次磁盘),而且还是顺序写的.

在这之后,有一个读请求
```
select * from t where k in (k1,k2)
```

如果读语句发生在更新语句后不久,内存中的数据都还在,那么此时的这两个读操作就与系统表空间(ibdata1)和redo log(ib_log_fileX)无关了.所以下面流程图中没画出这两部分:
![uh4ah4.png](https://s2.ax1x.com/2019/10/08/uh4ah4.png)

1.	读page 1 的时候,直接从内存返回.
2.	读page 2 的时候,需要把page 2 从磁盘读入内存中,然后应用change buffer里面的操作日志,生成一个正确的版本并返回结果.

可以看到,知道需要读page 2 的时候,这个数据页才会被读入内存.

所以,如果要简单对比这两个机制在提升更新性能上的收益的话,redo log主要节省的是随机写磁盘的IO消耗(转成顺序写,并且能够合并多个写操作为一个写操作),而change buffer主要节省的则是随机读磁盘的IO消耗(避免了每次更新都要将记录所在的数据页从磁盘读到内存中再应用更新,这个读是随机读,消耗大).