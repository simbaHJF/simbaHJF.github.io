---
layout:     post
title:      "redis数据结构"
date:       2021-03-08 22:30:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - redis

---



## 导航
[一. 简单动态字符串 SDS](#jump1)
<br>
[二. 链表](#jump2)
<br>
[三. 轻量级锁](#jump3)
<br>
[四. 偏向锁](#jump4)
<br>






<br><br>
## <span id="jump1">一. 简单动态字符串 SDS</span>

Redis没有直接使用C语言传统的字符串表示,而是自己构建了一种名为简单动态字符串(SDS)的抽象类型,并将SDS用作Redis的默认字符串表示.C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方,比如打印日志.<br>

SDS处用来保存数据库中的字符串值外,还被用作缓冲区:AOF模块中断AOF缓存区,以及客户端状态中的输入缓冲区,都是由SDS实现.<br>


比起C字符串,SDS具有以下优点:

<br>
**<font size="3">1. SDS常数复杂度获取字符串长度,而C字符串不记录长度,需遍历得知</font>** <br>


**<font size="3">2. 杜绝缓冲区溢出 ----- 自动扩容机制</font>** <br>


**<font size="3">3. 减少修改字符串长度时所需的内存重分配次数</font>** <br>

* 空间预分配 ----- 修改后长度小于1M,分配同当前长度相同的未使用空间;大于等于1M,分配1M的未使用空间
* 惰性空间释放 ----- 修改字符串变短后,空间不立即释放,留作未使用空间


**<font size="3">4. 二进制安全</font>** <br>


**<font size="3">5. 兼容部分C字符串函数</font>** <br>



<br><br>
## <span id="jump2">二. 链表</span>

Redis中列表键的底层实现之一.

*	链表被广泛使用于实现Redis的各种功能,比如列表建,发布与订阅,慢查询,监视器等.
*	每个链表节点由一个listNode结构来表示,每个节点都有一个指向前置节点和后置节点的指针,所以Redis的链表实现是双向链表
*	每个链表使用一个list结构来表示,这个结构带有表头节点指针,表尾节点指针,以及链表长度等信息.
*	链表表头节点的前置节点和表尾节点的后置节点都指向NULL,Redis的链表实现是无环链表
*	通过链表设置不同的类型特定函数,Redis的链表可以用于保存各种不同类型的值.



<br><br>
## <span id="jump3">三. 字典</span>

Redis的数据库就是使用字典作为底层实现的.另外,字典还是哈希键的底层实现之一.<br>

Redis的字典中,解决键冲突的方法是:链地址法.<br>

一个普通状态下(没有进行rehash)的字典结构,如下图所示
[![61uyOf.png](https://s3.ax1x.com/2021/03/08/61uyOf.png)](https://imgtu.com/i/61uyOf)

ht属性是一个包含两个项的数组,数组中每项都是一个哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]进行rehash时使用.除了ht[1]外,另一个和rehash有关的属性就是rehashidx,它记录了rehash目前的进度,如果目前没有在进行rehash,那么它的值为-1.<br>


<br>
**<font size="4">rehash</font>** <br>

随着操作的不断执行,哈希表保存的键值对会逐渐地增多或者减少,为了让哈希表的负载因子维持在一个合理的范围之内,当哈希表保存的键值对数量太多或者太少时,程序需要对哈希表的大小进行相应的扩展或者收缩.扩展和收缩哈希表的工作可以通过执行rehash操作来完成,Redis对字典的哈希表执行rehash的步骤如下:

1.	为字典的ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作,以及ht[0]当前包含的键值对数量(也即是ht[0].used属性的值):
	*	如果执行的是扩展操作,那么ht[1]的大小为[1第一个大于等于ht[0].used * 2 的 2 ^ n.
	*	如果执行的是收缩操作,那么ht[1]的大小为第一个大于等于ht[0].used的 2 ^ n.
2.	将保存在ht[0]中的所有键值对rehash到ht[1]上面:rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上.
3.	当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表),释放ht[0],将ht[1]置为ht[0],并在ht[1]新创建一个空白哈希表,为下一次rehash做准备

举个例子,假设程序要对下图所示字典的ht[0]进行扩展操作:
![QaE0yt.png](https://s2.ax1x.com/2019/12/08/QaE0yt.png)

那么程序将执行以下步骤:

1.	ht[0].used当前的值为4, 4 * 2 = 8, 而8(2 ^ 3)恰好是第一个大于等于8的2的n次方,所以程序会将ht[1]哈希表的大小设置为8,下图展示了ht[1]在分配空间之后,字典的样子:
![QaEOp9.png](https://s2.ax1x.com/2019/12/08/QaEOp9.png)

2.	将ht[0]包含的四个键值对都rehash到ht[1],如下图:
![QavMX4.png](https://s2.ax1x.com/2019/12/08/QavMX4.png)

3.	释放ht[0],并将ht[1]设置为ht[0],然后为ht[1]分配一个空白哈希表,如下图所示.至此,对哈希表的扩展操作执行完毕,程序成功将哈希表的大小从原来的4改为现在的8.
![QaxJbj.png](https://s2.ax1x.com/2019/12/08/QaxJbj.png)


<br>
**<font size="4">渐进式rehash</font>** <br>

扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面,但是,这个rehash动作并不是一次性,集中式的完成的,而是分多次,渐进式的完成的.<br>

这样做的原因在于,如果ht[0]里面只保存着四个键值对,那么服务器可以在瞬间就将这些键值对全部rehash到ht[1];但是,如果哈希表里保存的键值对数量不是四个,而是四百万,四千万甚至四亿个键值对,那么要一次性将这些键值对全部rehash到ht[1]的话,庞大的计算量可能会导致服务器在一段时间内停止服务.因此,为了避免rehash 对服务器性能造成影响,服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],而是分多次,渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1].<br>

以下是哈希表渐进式rehash的详细步骤:

1.	为ht[1]分配空间,让字段同时持有ht[0]和ht[1]两个哈希表
2.	在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0,表示rehash工作正式开始
3.	在rehash进行期间,每次对字典执行添加,删除,查找或者更新操作时,程序除了执行指定的操作以外,还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后,程序将rehashidx属性的值增一.
4.	随着字典操作的不断执行,最终在某个时间点上,ht[0]的所有键值对都会被rehash至ht[1],这时程序将rehashidx属性的值设为-1,表示rehash操作已完成.

下面各图,展示了一次渐进式rehash的完整过程:

*	准备开始rehash
![Qd9Tpt.png](https://s2.ax1x.com/2019/12/08/Qd9Tpt.png)

*	rehash索引0上的键值对
![QdC3He.png](https://s2.ax1x.com/2019/12/08/QdC3He.png)

*	rehash索引1上的键值对
![QdC0u8.png](https://s2.ax1x.com/2019/12/08/QdC0u8.png)

*	rehash索引2上的键值对
![QdPZqS.png](https://s2.ax1x.com/2019/12/08/QdPZqS.png)

*	rehash索引3上的键值对
![QdPJqU.png](https://s2.ax1x.com/2019/12/08/QdPJqU.png)

*	rehash执行完毕
![QdPrM6.png](https://s2.ax1x.com/2019/12/08/QdPrM6.png)



##	渐进式rehash执行期间的哈希表操作

因为在进行渐进式rehash的过程中,字典会同时使用ht[0]和ht[1]两个哈希表,所以在渐进式rehash进行期间,字典的删除,查找,更新等操作会在两个哈希表上进行.例如,要在字典里面查找一个键的话,程序会先在ht[0]里面进行查找,如果没找到的话,就会继续到ht[1]里面进行查找,诸如此类.

另外,在渐进式rehash执行期间,新添加到字典的键值对一律会被保存到ht[1]里面,而ht[0]则不再进行任何添加操作,这一措施保证了ht[0]包含的键值对数量会只减不增,并随着rehash操作的执行而最终变成空表.


##	重点总结:

*	字典被广泛用于实现Redis的各种功能,其中包括数据库和哈希键.
*	Redis中的字典使用哈希表作为底层实现,每个字典带有两个哈希表,一个平时使用,另一个仅在rehash时使用.
*	当字典被用作数据库的底层实现,或者哈希键的底层实现时,Redis使用MurmurHash2算法来计算键的哈希值
*	哈希表使用链地址法来解决键冲突,被分配到同一个索引上的多个键值对会连接成一个单向链表.
*	在对哈希表进行扩展或者收缩操作时,程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面,并且这个rehash过程并不是一次性完成的,而是渐进式地完成的.




#	跳跃表

Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成员是比较长的字符串时,Redis就会使用跳跃表作为有序集合键的底层实现.




#	整数集合

整数集合是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时,Redis就会使用整数集合作为集合键的底层实现.
整数集合是Redis用于保存整数值的集合抽象数据结构,他可以保存类型为int16_t,int32_t,int64_t的整数值,并且保证集合中不会出现重复元素.


##	升级

每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要进行升级,然后才能将新元素添加到整数集合里面.

升级整数集合并添加新元素共分为三步进行:<br>

1.	根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间.
2.	将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位置上,而且在放置元素的过程中,需要维持底层数组的有序性质不变.
3.	将新元素添加到底层数组里面

整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态




#	压缩列表

压缩列表是列表建和哈希键的底层实现之一.当一个列表键只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表建的底层实现.<br>
另外,当一个哈希键只包含少量键值对,并且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希键的底层实现.


##	重点总结:

*	压缩列表是一种为节约内存而开发的顺序型数据结构
*	压缩列表被用作列表键和哈希键的底层实现之一
*	压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值.
*	添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高




#	列表对象

列表对象的编码可以使zplist或者linkedlist.

###	编码转换

当列表对象可以同时满足以下两个条件时,列表对象使用ziplist编码:

*	列表对象保存的所有字符串元素的长度都小于64字节;
*	列表对象保存的元素数量小于512个;

不能满足这两个条件的列表对象需要使用linkedlist编码




#	哈希对象

哈希对象的编码可以是ziplist或者hashtable

###	编码转换

当哈希对象可以同时满足以下两个条件时,哈希对象使用ziplist编码:

*	哈希对象保存的所有键和值的字符串长度都小于64字节;
*	哈希对象保存的键值对数量小于512个;

不能满足这两个条件的哈希对象需要使用hashtable编码




#	集合对象

集合对象的编码可以是intset或者hashtable.

###	编码转换

当集合对象可以同时满足以下两个条件时,对象使用inset编码:

*	集合对象保存的所有元素都是整数值;
*	集合对象保存的元素数量不超过512个;

不能满足这两个条件的集合对象需要使用hashtable编码




#	有序集合对象

有序集合对象的编码可以是ziplist或者skiplist.

**<font color="red">注意,skiplist编码的有序集合对象使用zset结构作为底层实现,一个zset结构同时包含一个字典和一个跳跃表.</font>**

为什么有序集合需要同时使用跳跃表和字典来实现呢?

理论上,有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现,但无论单独使用字典还是跳跃表,在性能上对比起同时使用字典和跳跃表都会有所降低.

字典保证了O(1)复杂度查找成员的分值的特性,但是在进行范围操作--比如ZRANK,ZRANGE等命令时,复杂度升高,效率降低.

而跳跃表在范围性操作时,复杂度较低,性能较好,但根据成员查找分值的操作复杂度将会上升为O(log N).

因此,为了让有序集合的查找和范围型操作都尽可能快地执行,Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合.


###	编码转换

当有序集合对象可以同时满足以下两个条件时,对象使用ziplist编码:

*	有序集合保存的元素数量小于128个;
*	有序集合保存的所有元素成员的长度都小于64字节;

不能满足以上两个条件的有序集合对象将使用skiplist编码





#	Redis中对象的内存回收

因为C语言不具备自动内存回收功能,所以,Redis在自己的对象系统中构建了一个引用计数(reference counting)技术实现的内存回收机制.

对象的引用计数信息会随着对象的使用状态而不断变化:

*	在创建一个新对象时,引用计数的值会被初始化为1
*	当对象被一个新程序使用时,它的引用计数值会被增1;
*	当对象不再被一个程序使用时,它的引用计数值会被减1;
*	当对象的引用计数值变为0时,对象所占用的内存会被释放.