---
layout:     post
title:      "redis 复制"
date:       2021-03-13 17:00:00 +0800
author:     "simba"
header-img: "img/post-bg-miui6.jpg"
tags:
    - redis

---



## 导航
[一. 前言](#jump1)
<br>
[二. 旧版复制功能的实现](#jump2)
<br>
[三. 时间事件](#jump3)
<br>
[四. 新版复制功能的实现](#jump4)
<br>
[五. 部分重同步的实现](#jump5)
<br>
[六. PSYNC命令的实现](#jump6)
<br>
[七. 心跳检测](#jump7)









<br><br>
## <span id="jump1">一. 前言</span>

在Redis中,可以通过执行SLAVEOF命令或者设置slaveof选型,让一个服务器去复制(replicate)另一个服务器,称被复制的服务器为主服务器(master),对主服务器进行复制的服务器则被称为从服务器(slave).进行复制中的主从服务器双方的数据库将保存相同的数据,称为"数据库状态一致".<br>



<br><br>
## <span id="jump2">二. 旧版复制功能的实现</span>

Redis的复制功能分为同步(sync)和命令传播(command propagate)两个操作:
* 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
* 命令传播操作则用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态出现不一致时,让主从服务器的数据库重新回到一直状态


<br>
**<font size="4">同步</font>** <br>

当客户端向从服务器发送SLAVEOF命令,要求从服务器复制主服务器时,从服务器首先需要执行同步操作,也即是,将从服务器的数据库状态更新至主服务器当前所处的数据库状态.<br>

从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成,以下是SYNC命令的执行步骤:
1. 从服务器向主服务器发送SYNC命令
2. 收到SYNC命令的主服务器执行BGSAVE命令,在后台生成一个RDB文件,并使用一个缓冲区记录从现在开始执行的所有写命令
3. 当主服务器的BGSAVE命令执行完毕时,主服务器会将BGSAVE命令生成的RDB文件发送给从服务器,从服务器接收并载入这个RDB文件,将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器,从服务器执行这些写命令,将自己的数据库状态更新至主服务器数据库当前所处的状态

[![6w9j3j.png](https://s3.ax1x.com/2021/03/13/6w9j3j.png)](https://imgtu.com/i/6w9j3j)


<br>
**<font size="4">命令传播</font>** <br>

在同步操作执行完毕之后,主从服务器两者的数据库将达到一致状态,但随着主服务器执行客户端发送的写命令,主服务器的数据库就有可能会被修改,导致主从服务器状态不再一致.为了让主从服务器再次回到一致状态,主服务器需要对从服务器执行命令传播操作:主服务器会将自己执行的写命令,发送给从服务器执行,当从服务器执行了相同的写命令之后,主从服务器将再次回到一致状态<br>



<br><br>
## <span id="jump3">三. 旧版复制功能的缺陷</span>

Redis中,从服务器对主服务器的复制可以分为以下两种情况:
* 初次复制: 从服务器以前没有复制过任何主服务器,或者从服务器当前要复制的主服务器和上次复制的主服务器不同
* 断线后重复制: 处于命令传播阶段的的主从服务器因为网络原因而中断了复制,但从服务器通过自动重连接重新连上了主服务器,并继续复制主服务器.

对于初次复制来说,旧版复制功能可以很好地完成任务,但对于断线后重复制来说,旧版复制功能就十分低效.SYNC是一个十分重的操作命令.



<br><br>
## <span id="jump4">四. 新版复制功能的实现</span>

为解决旧版复制功能在处理断线重复制情况时的低效问题,Redis从2.8版本开始,使用PSYNC命令代替SYNC命令来执行复制时的同步操作.PSYNC具有完整重同步和部分重同步两种模式:
* 完整重同步用于处理初次复制情况,其执行步骤和SYNC命令的执行步骤基本一样,都是通过让主服务器创建并发送RDB文件,以及向从服务器发送保存在缓冲区里面的写命令来进行同步.
* 部分重同步则用于处理断线后重复制情况:当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态.



<br><br>
## <span id="jump5">五. 部分重同步的实现</span>

部分重同步功能由以下三个部分构成:
* 主服务器的复制偏移量(replication offset)和从服务器的复制偏移量
* 主服务器的复制积压缓冲区(replication backlog)
* 服务器的运行ID(run ID)


<br>
**<font size="4">复制偏移量</font>** <br>

执行复制的双方 ----- 主服务器和从服务器会分别维护一个复制偏移量
* 主服务器每次向从服务器传播N个字节的数据时,就将自己的复制偏移量的值加上N
* 从服务器每次收到主服务器传播来的N个字节的数据时,就将自己的复制偏移量的值加上N

[![60Km8I.png](https://s3.ax1x.com/2021/03/14/60Km8I.png)](https://imgtu.com/i/60Km8I)

如果这是主服务器向三个从服务器传播长度为33字节的数据,那么主服务器的复制偏移量将更新为10119,而三个从服务器在接收到主服务器传播的数据之后,也会将复制偏移量更新为10119.
[![60KG5j.png](https://s3.ax1x.com/2021/03/14/60KG5j.png)](https://imgtu.com/i/60KG5j)

通过对比主从服务器的复制偏移量,程序可以很容易地知道主从服务器是否处于一致状态:
* 如果主从服务器处于一致状态,那么主从服务器两者的偏移量总是相同的
* 相反,如果主从服务器两者的偏移量不相同,那么说明主从服务器并未处于一致状态

考虑以下例子:假设主从服务器的复制偏移量都在10086时,在主服务器要向从服务器传播33字节之前,从服务器A断线了,那么主服务器传播的数据将只有从服务器B和C能收到,在这之后,主服务器、从服务器B和C,三个服务器的复制偏移量都将更新为10019,而断线的从服务器A的复制偏移量仍然停留10086,这说明从服务器A与主服务器并不一致了.
[![60MZeU.png](https://s3.ax1x.com/2021/03/14/60MZeU.png)](https://imgtu.com/i/60MZeU)


<br>
**<font size="4">复制积压缓冲区</font>** <br>

假设上述从服务器A断线之后立即重连主服务器成功,并向主服务器发送PSYNC命令,报告从服务器A当前的复制偏移量为10086,那么此时主服务器应该对从服务器执行完整重同步还是部分重同步呢?如果执行部分重同步,主服务器该如何补偿服务器A在断线期间丢失的部分数据呢?以上问题都和复制及压缓冲区有关.<br>

复制积压缓冲区是由主服务器维护的一个固定长度(fixed-size)先进先出(FIFO)队列,默认大小为1MB.<br>

当主服务器进行命令传播时,它不仅会将写命令发送给所有从服务器,还会将写命令入队到复制及压缓冲区里面.因此,主服务器的复制及压缓冲区里面会保存着一部分最近传播的写命令,并且复制积压缓冲区会为队列中的每个字节记录响应的复制偏移量.<br>

当从服务器重新连接上主服务器时,从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器,主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作:
* 如果offset偏移量之后的数据仍然存在于复制积压缓冲区里面,那么主服务器将对从服务器执行部分重同步操作.主服务器向从服务器发送 +CONTINUE 回复,表示数据同步将以部分重同步模式来进行
* 相反,如果offset偏移量之后的数据已经不存在于复制积压缓冲区,那么主服务器将对从服务器执行完整重同步操作.主服务器向从服务器发送 +FULLRESYNC 回复,表示数据同步将以完整重同步模式来进行.


<br>
**<font size="4">服务器运行ID</font>** <br>

除了复制偏移量和复制积压缓冲区之外,实现部分重同步还需要用到服务器运行ID:
* 每个Redis服务器,不论主服务器还是从服务器,都会有自己的运行ID
* 运行ID在服务器启动时自动生成,由40个随机的十六进制字符组成

当从服务器对主服务器进行初次复制时,主服务器会将自己的运行ID传送给从服务器,而从服务器则会将这个运行ID保存起来.当从服务器断线并重新连上一个主服务器时,从服务器将向当前连接的主服务器发送之前保存的运行ID:
* 如果从服务器保存的运行ID和当前连接的主服务器运行ID相同,那么说明从服务器断线之前复制的就是当前连接的这个主服务器,主服务器可以继续尝试执行部分重同步操作
* 相反,如果从服务器保存的运行ID和当前连接的主服务器的运行ID不同,那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器,主服务器将对从服务器执行完整重同步操作



<br><br>
## <span id="jump6">六. PSYNC命令的实现</span>

[![60aLNt.png](https://s3.ax1x.com/2021/03/14/60aLNt.png)](https://imgtu.com/i/60aLNt)



<br><br>
## <span id="jump7">七. 心跳检测</span>

在命令传播阶段,从服务器默认会以每秒一次的频率,向主服务器发送命令:<br>
``
REPLCONF ACK <replication_offset>
``

发送 REPLCONF ACK 命令对于主从服务器有三个作用:
* 检测主从服务器的网络连接状态
* 辅助实现 min-slaves 选项
* 检测命令丢失


<br>
**<font size="4">检测主从服务器的网络连接状态</font>** <br>

主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常:如果主服务器超过一秒没有接收到从服务器发来的REPLCONF ACK命令,那么主服务器就知道主从服务器之间的连接出现问题了.<br>


<br>
**<font size="4">辅助实现 min-slaves 选项</font>** <br>

Redis的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在不安全的情况下执行写命令.例如,如果向主服务器提供以下设置:
```
min-slaves-to-write 3
min-slaves-max-lag 10
```

那么在从服务器的数量少于3个,或者三个从服务器的延迟(lag)值都大于或等于10秒时,主服务器将拒绝执行写命令.


<br>
**<font size="4">检测命令丢失</font>** <br>

如果因为网络故障,主服务器传播给从服务器的写命令在半路丢失,那么当从服务器向主服务器发送 REPLCONF ACK 命令时,主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量,然后主服务器就会根据从服务器提交的复制偏移量,在复制积压缓冲区里面找到从服务器缺少的数据,并将这些数据重新发送给从服务器.